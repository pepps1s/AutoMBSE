[
    {
        "code": "package ServerSequenceOutsideRealization_3 {\n\timport ServerSequenceModelOutside::*;\n\timport Configuration::*;\n\t\n\tpackage Configuration {\n\t\t\n\t\tport def PublicationPort {\n\t\t\tin ref publish : Publish;\n\t\t}\n\t\t\n\t\tport def SubscriptionPort {\n\t\t\tin ref subscribe : Subscribe;\n\t\t\tout ref deliver : Deliver;\n\t\t}\n\t\t\n\t\tinterface def PublicationInterface {\n\t\t\tend source : ~PublicationPort;\n\t\t\tend target : PublicationPort;\n\t\t}\n\t\t\n\t\tinterface def SubscriptionInterface {\n\t\t\tend source : ~SubscriptionPort;\n\t\t\tend target : SubscriptionPort;\n\t\t}\n\t\t\n\t\tpart producer_3[1] {\n\t\t\tattribute someTopic : String;\n\t\t\tprivate item somePublication;\n\t\t\t\n\t\t\tport publicationPort : ~PublicationPort {\n\t\t\t\tout ref :>> publish;\n\t\t\t}\n\t\t\t\n\t\t\tperform action producerBehavior {\n\t\t\t\taction publish {\n\t\t\t\t\tout ref request : Publish[1] = Publish(someTopic, somePublication);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t/* Internal flows are instantaneous to make arrival/leave ordering in SequenceModelOutside.sysml\n\t\t\t * equivalent to ordering participant internals in ServerSequenceRealization-3.sysml. */\n\t\t\tflow publish_request from producerBehavior.publish.request to publicationPort.publish\n\t\t\t\t{ attribute :>> isInstant = true;}\n\t\t}\n\t\t\n\t\tinterface publication_interface : PublicationInterface connect producer_3.publicationPort to server_3.publicationPort {\n\t\t\tflow publish_request from publication_interface.source.publish to publication_interface.target.publish;\n\t\t}\n\t\t\n\t\tpart server_3[1] {\n\t\t\tport publicationPort : PublicationPort {\n\t\t\t\tin ref :>> publish;\n\t\t\t}\n\t\t\tport subscriptionPort : SubscriptionPort {\n\t\t\t\tin ref :>> subscribe;\n\t\t\t\tout ref :>> deliver;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\tflow subscribe_request from subscriptionPort.subscribe to serverBehavior.subscribing.request\n\t\t\t\t{ attribute :>> isInstant = true;}\n\t\t\tflow publish_request from publicationPort.publish to serverBehavior.publishing.request\n\t\t\t\t{ attribute :>> isInstant = true;}\n\t\t\tflow deliver_response from serverBehavior.delivering.response to subscriptionPort.deliver\n\t\t\t\t{ attribute :>> isInstant = true;}\n\t\t\t\n\t\t\tperform action serverBehavior {\n\t\t\t\t\n\t\t\t\taction subscribing {\n\t\t\t\t\tin ref request : Subscribe[1];\n\t\t\t\t\tout attribute topic : String[1] = request.topic;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthen merge continuePublishing;\t\t\t\n\t\t\t\tthen action publishing {\n\t\t\t\t\tin ref request : Publish[1];\n\t\t\t\t\tout attribute topic[1] = request.topic;\n\t\t\t\t\tout ref publication[1] = request.publication;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthen decide;\n\t\t\t\t\tif publishing.topic == subscribing.topic then delivering;\n\t\t\t\t\telse continuePublishing;\n\t\t\t\t\t\n\t\t\t\tthen action delivering {\n\t\t\t\t\tin topic : String[1] = subscribing.topic;\n\t\t\t\t\tin publication[1] = publishing.publication;\n\t\t\t\t\tout ref response : Deliver = Deliver(publication);\n\t\t\t\t}\n\t\t\t\tthen continuePublishing;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface subscription_interface : SubscriptionInterface connect consumer_3.subscriptionPort to server_3.subscriptionPort {\n\t\t\tflow subscribe_request from subscription_interface.source.subscribe to subscription_interface.target.subscribe;\n\t\t\tflow deliver_response from subscription_interface.target.deliver to subscription_interface.source.deliver;\n\t\t}\n\t\t\n\t\tpart consumer_3[1] {\n\t\t\tattribute myTopic : String;\n\t\t\t\n\t\t\tport subscriptionPort : ~SubscriptionPort {\n\t\t\t\tout ref :>> subscribe;\n\t\t\t\tin ref :>> deliver;\n\t\t\t}\n\t\t\t\n\t\t\tflow subscribe_request from consumerBehavior.subscribe.request to subscriptionPort.subscribe\n\t\t\t\t{ attribute :>> isInstant = true;}\n\t\t\tflow deliver_response from subscriptionPort.deliver to consumerBehavior.delivery.response\n\t\t\t\t{ attribute :>> isInstant = true;}\n\n\t\t\tperform action consumerBehavior {\n\t\t\t\taction subscribe {\n\t\t\t\t\tout ref request : Subscribe = Subscribe(myTopic);\n\t\t\t\t}\n\t\t\t\tthen action delivery {\n\t\t\t\t\tin ref response : Deliver;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpart realization_2 : PubSubSequence {\n\t\tpart :>> producer :> producer_3 {\n\t\t\tevent producerBehavior.publish[1] :>> publish_source_event;\n\t\t}\n\n\t\tpart :>> server :> server_3 {\n\t\t\tevent serverBehavior.subscribing[1] :>> subscribe_target_event;\n\t\t\tevent serverBehavior.publishing[1] :>> publish_target_event;\n\t\t\tevent serverBehavior.delivering[1] :>> deliver_source_event;\n\t\t}\n\t\t\n\t\tpart :>> consumer :> consumer_3 {\n\t\t\tevent consumerBehavior.subscribe[1] :>> subscribe_source_event;\n\t\t\tevent consumerBehavior.delivery[1] :>> deliver_target_event;\n\t\t}\n\t\t\n\t\tflow :>> publish_message from producer.producerBehavior.publish.request to server.serverBehavior.publishing.request {\n\t\t\tevent producer.publish_request[1];\n\t\t\tthen event publication_interface.publish_request[1];\n\t\t\tthen event server.publish_request[1];\n\t\t}\n\t\t\n\t\tflow :>> subscribe_message from consumer.consumerBehavior.subscribe.request to server.serverBehavior.subscribing.request {\n\t\t\tevent consumer.subscribe_request[1];\n\t\t\tthen event subscription_interface.subscribe_request[1];\n\t\t\tthen event server.subscribe_request[1];\n\t\t}\n\t\t\n\t\tflow :>> deliver_message from server.serverBehavior.delivering.response to consumer.consumerBehavior.delivery.response {\n\t\t\tevent server.deliver_response[1];\n\t\t\tthen event subscription_interface.deliver_response[1];\n\t\t\tthen event consumer.deliver_response[1];\n\t\t}\n\t}\n}",
        "description": "The SysML-V2 code defines a publish-subscribe system where producers publish messages, servers handle subscriptions and deliveries, and consumers receive messages, all coordinated through interfaces and ports with instantaneous internal flows for message handling."
    },
    {
        "code": "package ServerSequenceOutsideRealization_2 {\n\timport ServerSequenceModelOutside::*;\n\timport Configuration::*;\n\t\n\tpackage Configuration {\n\t\t\n\t\tport def PublicationPort;\n\t\t\n\t\tport def SubscriptionPort;\n\t\t\n\t\tpart producer_2[1] {\n\t\t\tattribute someTopic : String;\n\t\t\tprivate item somePublication;\n\t\t\t/* Requiring FIFO sort (as opposed to just default) to make arrival/leave ordering\n\t\t\t * in ServerSequenceModelOutside.sysml equivalent to accept/send ordering in\n\t\t\t * ServerSquenceRealization-2.sysml. */\n\t\t\t:>> incomingTransferSort = Occurrences::earlierFirstIncomingTransferSort;\n\t\t\t\n\t\t\tport publicationPort : ~PublicationPort;\n\t\t\t\n\t\t\tperform action producerBehavior {\n\t\t\t\taction publish send Publish(someTopic, somePublication) via publicationPort;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface producer_2.publicationPort to server_2.publicationPort {\n\t\t\tbind source::outgoingTransfersFromSelf = target::incomingTransfersToSelf;\n\t\t}\n\t\t\n\t\tpart server_2[1] {\n\t\t\tport publicationPort : PublicationPort;\n\t\t\tport subscriptionPort : SubscriptionPort;\n\t\t\t:>> incomingTransferSort = Occurrences::earlierFirstIncomingTransferSort;\n\t\t\t\n\t\t\texhibit state serverBehavior {\n\t\t\t\tentry; then waitForSubscription;\n\t\t\t\t\n\t\t\t\tstate waitForSubscription;\n\t\t\t\ttransition subscribing\n\t\t\t\t\tfirst waitForSubscription\n\t\t\t\t\taccept sub : Subscribe via subscriptionPort\n\t\t\t\t\tthen waitForPublication;\n\t\t\t\t\t\n\t\t\t\tstate waitForPublication;\n\t\t\t\ttransition delivering\n\t\t\t\t\tfirst waitForPublication\n\t\t\t\t\taccept pub : Publish via publicationPort\n\t\t\t\t\tif pub.topic == subscribing.sub.topic\n\t\t\t\t\tdo send Deliver(pub.publication) to subscribing.sub.subscriber\n\t\t\t\t\tthen waitForPublication;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface consumer_2.subscriptionPort to server_2.subscriptionPort {\n\t\t\tbind source::outgoingTransfersFromSelf = target::incomingTransfersToSelf;\n\t\t}\n\t\t\n\t\tpart consumer_2[1] {\n\t\t\tattribute myTopic : String;\n\t\t\t:>> incomingTransferSort = Occurrences::earlierFirstIncomingTransferSort;\n\t\t\t\n\t\t\tport subscriptionPort : ~SubscriptionPort;\n\t\t\t\n\t\t\tperform action consumerBehavior {\n\t\t\t\taction subscribe send Subscribe(myTopic, consumer_2) to server_2;\n\t\t\t\tthen action delivery accept Deliver via consumer_2;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpart realization_2 : PubSubSequence {\n\t\tpart :>> producer :> producer_2;\n\t\tpart :>> server :> server_2;\n\t\tpart :>> consumer :> consumer_2;\n\n\t\tmessage :>> publish_message: Transfers::MessageTransfer {\n \t\t\tend :>> source = producer.publicationPort;\n \t\t\tend :>> target = server.publicationPort;\n \t\t}\n\t\tmessage :>> subscribe_message: Transfers::MessageTransfer {\n \t\t\tend :>> source = consumer.subscriptionPort;\n \t\t\tend :>> target = server.subscriptionPort;\n \t\t}\n\t\tmessage :>> deliver_message: Transfers::MessageTransfer {\n \t\t\tend :>> source = server;\n \t\t\tend :>> target = consumer;\n \t\t}\n \t\t\n \t\t/* Binding sent/accept messages to specification model messages. */\n\t\t  /* Sends */\n \t\tbind producer_2.producerBehavior.publish.sentMessage = publish_message;\n \t\tbind consumer_2.consumerBehavior.subscribe.sentMessage = subscribe_message;\n \t\tbind server_2.serverBehavior.delivering.effect.sentMessage = deliver_message;\n \t\t  /* Accepts */\n \t\tbind consumer_2.consumerBehavior.delivery.acceptedMessage = subscribe_message;\n \t\tbind server_2.serverBehavior.subscribing.accepter.acceptedMessage = subscribe_message;\n \t\tbind server_2.serverBehavior.delivering.accepter.acceptedMessage = publish_message;\n\t}\n}",
        "description": "The SysML-V2 code defines a publish-subscribe system where a producer publishes messages to a server, which then delivers them to a consumer based on topic subscriptions, ensuring message transfers are ordered using FIFO sorting."
    },
    {
        "code": "package ServerSequenceModelOutside {\n\timport ServerSequenceModel::*;\n\n\tpart def PubSubSequenceOutside :> PubSubSequence {\n\t\tpart :>> producer {\n\t\t\tevent publish_source_event = publish_message.start;\n\t\t}\n\t\t\n\t\tpart :>> server {\n\t\t\tevent occurrence :>> subscribe_target_event = subscribe_message.done;\n\t\t\tthen event occurrence :>> publish_target_event = publish_message.done;\n\t\t\tthen event occurrence :>> deliver_source_event = deliver_message.start;\n\t\t}\n\t\t\n\t\tpart :>> consumer {  /* Redundant with timing constraints on server and generic transfers. */\n\t\t\tevent occurrence :>> subscribe_source_event = subscribe_message.start;\n\t\t\tthen event occurrence :>> deliver_target_event = deliver_message.done;\n\t\t}\n\t}\n}",
        "description": "The SysML-V2 code defines a sequence model for a publish-subscribe system where a producer publishes messages, a server handles subscription and message delivery, and a consumer receives delivered messages, with events marking the start and completion of each action."
    },
    {
        "code": "package ServerSequenceRealization_2 {\n\timport ServerSequenceModel::*;\n\timport Configuration::*;\n\t\n\tpackage Configuration {\n\t\t\n\t\tport def PublicationPort;\n\t\t\n\t\tport def SubscriptionPort;\n\t\t\n\t\tpart producer_2[1] {\n\t\t\tattribute someTopic : String;\n\t\t\tprivate item somePublication;\n\t\t\t\n\t\t\tport publicationPort : ~PublicationPort;\n\t\t\t\n\t\t\tperform action producerBehavior {\t\n\t\t\t\taction publish send Publish(someTopic, somePublication) via publicationPort;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface producer_2.publicationPort to server_2.publicationPort {\n\t\t\tbind source::outgoingTransfersFromSelf = target::incomingTransfersToSelf;\n\t\t}\n\t\t\n\t\tpart server_2[1] {\n\t\t\tport publicationPort : PublicationPort;\n\t\t\tport subscriptionPort : SubscriptionPort;\n\t\t\t\n\t\t\texhibit state serverBehavior {\n\t\t\t\tentry; then waitForSubscription;\n\t\t\t\t\n\t\t\t\tstate waitForSubscription;\n\t\t\t\ttransition subscribing\n\t\t\t\t\tfirst waitForSubscription\n\t\t\t\t\taccept sub : Subscribe via subscriptionPort\n\t\t\t\t\tthen waitForPublication;\n\t\t\t\t\t\n\t\t\t\tstate waitForPublication;\n\t\t\t\ttransition delivering\n\t\t\t\t\tfirst waitForPublication\n\t\t\t\t\taccept pub : Publish via publicationPort\n\t\t\t\t\tif pub.topic == subscribing.sub.topic\n\t\t\t\t\tdo send Deliver(pub.publication) to subscribing.sub.subscriber\n\t\t\t\t\tthen waitForPublication;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface consumer_2.subscriptionPort to server_2.subscriptionPort {\n\t\t\tbind source::outgoingTransfersFromSelf = target::incomingTransfersToSelf;\n\t\t}\n\t\t\n\t\tpart consumer_2[1] {\n\t\t\tattribute myTopic : String;\n\t\t\t\n\t\t\tport subscriptionPort : ~SubscriptionPort;\n\t\t\t\n\t\t\tperform action consumerBehavior {\n\t\t\t\taction subscribe send Subscribe(myTopic, consumer_2) to server_2;\n\t\t\t\tthen action delivery accept Deliver via consumer_2;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpart realization_2 : PubSubSequence {\n\t\tpart :>> producer :> producer_2 {\n\t\t\tevent producerBehavior.publish[1] :>> publish_source_event;\n\t\t}\n\n\t\tpart :>> server :> server_2 {\n\t\t\tevent serverBehavior.subscribing.accepter[1] :>> subscribe_target_event;\n\t\t\tevent serverBehavior.delivering.accepter[1] :>> publish_target_event;\n\t\t\tevent serverBehavior.delivering.effect[1] :>> deliver_source_event;\n\t\t}\n\t\t\n\t\tpart :>> consumer :> consumer_2 {\n\t\t\tevent consumerBehavior.subscribe[1] :>> subscribe_source_event;\n\t\t\tevent consumerBehavior.delivery[1] :>> deliver_target_event;\n\t\t}\n\n\t\tmessage :>> publish_message: Transfers::MessageTransfer {\n \t\t\tend :>> source = producer.publicationPort;\n \t\t\tend :>> target = server.publicationPort;\n \t\t}\n\t\tmessage :>> subscribe_message: Transfers::MessageTransfer {\n \t\t\tend :>> source = consumer.subscriptionPort;\n \t\t\tend :>> target = server.subscriptionPort;\n \t\t}\n\t\tmessage :>> deliver_message: Transfers::MessageTransfer {\n \t\t\tend :>> source = server;\n \t\t\tend :>> target = consumer;\n \t\t}\n \t\t\n \t\t/* Binding sent/accept messages to specification model messages. */\n\t\t  /* Sends */\n \t\tbind producer_2.producerBehavior.publish.sentMessage = publish_message;\n \t\tbind consumer_2.consumerBehavior.subscribe.sentMessage = subscribe_message;\n \t\tbind server_2.serverBehavior.delivering.effect.sentMessage = deliver_message;\n \t\t  /* Accepts */\n \t\tbind consumer_2.consumerBehavior.delivery.acceptedMessage = subscribe_message;\n \t\tbind server_2.serverBehavior.subscribing.accepter.acceptedMessage = subscribe_message;\n \t\tbind server_2.serverBehavior.delivering.accepter.acceptedMessage = publish_message;\n\t}\n}",
        "description": "The SysML-V2 code defines a publish-subscribe system where a producer publishes messages to a server, which then delivers them to the appropriate consumer based on subscriptions, using ports and interfaces to manage message transfers and bindings."
    },
    {
        "code": "package ServerSequenceRealization_3 {\n\timport ServerSequenceModel::*;\n\timport Configuration::*;\n\t\n\tpackage Configuration {\n\t\t\n\t\tport def PublicationPort {\n\t\t\tin ref publish : Publish;\n\t\t}\n\t\t\n\t\tport def SubscriptionPort {\n\t\t\tin ref subscribe : Subscribe;\n\t\t\tout ref deliver : Deliver;\n\t\t}\n\t\t\n\t\tinterface def PublicationInterface {\n\t\t\tend source : ~PublicationPort;\n\t\t\tend target : PublicationPort;\n\t\t}\n\t\t\n\t\tinterface def SubscriptionInterface {\n\t\t\tend source : ~SubscriptionPort;\n\t\t\tend target : SubscriptionPort;\n\t\t}\n\t\t\n\t\tpart producer_3[1] {\n\t\t\tattribute someTopic : String;\n\t\t\tprivate item somePublication;\n\t\t\t\n\t\t\tport publicationPort : ~PublicationPort {\n\t\t\t\tout ref :>> publish;\n\t\t\t}\n\t\t\t\n\t\t\tperform action producerBehavior {\n\t\t\t\taction publish {\n\t\t\t\t\tout ref request : Publish[1] = Publish(someTopic, somePublication);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tflow publish_request from producerBehavior.publish.request to publicationPort.publish;\n\t\t}\n\t\t\n\t\tinterface publication_interface : PublicationInterface connect producer_3.publicationPort to server_3.publicationPort {\n\t\t\tflow publish_request from publication_interface.source.publish to publication_interface.target.publish;\n\t\t}\n\t\t\n\t\tpart server_3[1] {\n\t\t\tport publicationPort : PublicationPort {\n\t\t\t\tin ref :>> publish;\n\t\t\t}\n\t\t\tport subscriptionPort : SubscriptionPort {\n\t\t\t\tin ref :>> subscribe;\n\t\t\t\tout ref :>> deliver;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\tflow subscribe_request from subscriptionPort.subscribe to serverBehavior.subscribing.request;\n\t\t\tflow publish_request from publicationPort.publish to serverBehavior.publishing.request;\n\t\t\tflow deliver_response from serverBehavior.delivering.response to subscriptionPort.deliver;\n\t\t\t\n\t\t\tperform action serverBehavior {\n\t\t\t\t\n\t\t\t\taction subscribing {\n\t\t\t\t\tin ref request : Subscribe[1];\n\t\t\t\t\tout attribute topic : String[1] = request.topic;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthen merge continuePublishing;\t\t\t\n\t\t\t\tthen action publishing {\n\t\t\t\t\tin ref request : Publish[1];\n\t\t\t\t\tout attribute topic[1] = request.topic;\n\t\t\t\t\tout ref publication[1] = request.publication;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tthen decide;\n\t\t\t\t\tif publishing.topic == subscribing.topic then delivering;\n\t\t\t\t\telse continuePublishing;\n\t\t\t\t\t\n\t\t\t\tthen action delivering {\n\t\t\t\t\tin topic : String[1] = subscribing.topic;\n\t\t\t\t\tin publication[1] = publishing.publication;\n\t\t\t\t\tout ref response : Deliver = Deliver(publication);\n\t\t\t\t}\n\t\t\t\tthen continuePublishing;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface subscription_interface : SubscriptionInterface connect consumer_3.subscriptionPort to server_3.subscriptionPort {\n\t\t\tflow subscribe_request from subscription_interface.source.subscribe to subscription_interface.target.subscribe;\n\t\t\tflow deliver_response from subscription_interface.target.deliver to subscription_interface.source.deliver;\n\t\t}\n\t\t\n\t\tpart consumer_3[1] {\n\t\t\tattribute myTopic : String;\n\t\t\t\n\t\t\tport subscriptionPort : ~SubscriptionPort {\n\t\t\t\tout ref :>> subscribe;\n\t\t\t\tin ref :>> deliver;\n\t\t\t}\n\t\t\t\n\t\t\tflow subscribe_request from consumerBehavior.subscribe.request to subscriptionPort.subscribe;\n\t\t\tflow deliver_response from subscriptionPort.deliver to consumerBehavior.delivery.response;\n\n\t\t\tperform action consumerBehavior {\n\t\t\t\taction subscribe {\n\t\t\t\t\tout ref request : Subscribe = Subscribe(myTopic);\n\t\t\t\t}\n\t\t\t\tthen action delivery {\n\t\t\t\t\tin ref response : Deliver;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tpart realization_2 : PubSubSequence {\n\t\tpart :>> producer :> producer_3 {\n\t\t\tevent producerBehavior.publish[1] :>> publish_source_event;\n\t\t}\n\n\t\tpart :>> server :> server_3 {\n\t\t\tevent serverBehavior.subscribing[1] :>> subscribe_target_event;\n\t\t\tevent serverBehavior.publishing[1] :>> publish_target_event;\n\t\t\tevent serverBehavior.delivering[1] :>> deliver_source_event;\n\t\t}\n\t\t\n\t\tpart :>> consumer :> consumer_3 {\n\t\t\tevent consumerBehavior.subscribe[1] :>> subscribe_source_event;\n\t\t\tevent consumerBehavior.delivery[1] :>> deliver_target_event;\n\t\t}\n\t\t\n\t\tflow :>> publish_message from producer.producerBehavior.publish.request to server.serverBehavior.publishing.request {\n\t\t\tevent producer.publish_request[1];\n\t\t\tthen event publication_interface.publish_request[1];\n\t\t\tthen event server.publish_request[1];\n\t\t}\n\t\t\n\t\tflow :>> subscribe_message from consumer.consumerBehavior.subscribe.request to server.serverBehavior.subscribing.request {\n\t\t\tevent consumer.subscribe_request[1];\n\t\t\tthen event subscription_interface.subscribe_request[1];\n\t\t\tthen event server.subscribe_request[1];\n\t\t}\n\t\t\n\t\tflow :>> deliver_message from server.serverBehavior.delivering.response to consumer.consumerBehavior.delivery.response {\n\t\t\tevent server.deliver_response[1];\n\t\t\tthen event subscription_interface.deliver_response[1];\n\t\t\tthen event consumer.deliver_response[1];\n\t\t}\n\t}\n}",
        "description": "The SysML-V2 code defines a publish-subscribe system where producers publish messages, consumers subscribe to topics, and a server manages the subscription and delivery of messages based on topic matching."
    },
    {
        "code": "package ServerSequenceModel {\n\timport ScalarValues::String;\n\timport SignalDefinitions::*;\n\n\tpackage SignalDefinitions {\n\t    item def Subscribe {\n\t    \tattribute topic : String;\n\t    \tref part subscriber;\n\t    }\n\t    \n\t\titem def Publish {\n\t\t\tattribute topic : String;\n\t\t\tref publication;\n\t\t}\n\t\t\n\t\titem def Deliver {\n\t\t\tref publication;\n\t\t}\n\t}\n\n\tpart def PubSubSequence {\n\t\tpart producer[1] {\n\t\t\tevent occurrence publish_source_event;\n\t\t}\n\t\t\n\t\tmessage publish_message from producer.publish_source_event to server.publish_target_event;\n\t\t\n\t\tpart server[1] {\n\t\t\tevent occurrence subscribe_target_event;\n\t\t\tthen event occurrence publish_target_event;\n\t\t\tthen event occurrence deliver_source_event;\n\t\t}\n\t\t\n\t\tmessage subscribe_message from consumer.subscribe_source_event to server.subscribe_target_event;\n\t\tmessage deliver_message from server.deliver_source_event to consumer.deliver_target_event;\n\t\t\n\t\tpart consumer {\n\t\t\tevent occurrence subscribe_source_event;\n\t\t\tthen event occurrence deliver_target_event;\n\t\t}\n\t}\n}",
        "description": "The SysML-V2 code defines a server sequence model for a publish-subscribe system, detailing the interactions between producers, a server, and consumers through events and messages for subscribing, publishing, and delivering content based on topics."
    },
    {
        "code": "package 'Flashlight Example' {\n\t\n\tattribute def OnOffCmd;\n\tattribute def Light;\n\t\n\tport def OnOffCmdPort {\n\t\tout onOffCmd : OnOffCmd;\n\t}\n\t\n\tport def LightPort {\n\t\tout light: Light;\n\t}\n\t\n\tpart context {\n\t\tpart user {\n\t\t\tport onOffCmdPort: OnOffCmdPort;\n\t\t\tperform illuminateRegion.sendOnOffCmd {\n\t\t\t\tout onOffCmd = onOffCmdPort.onOffCmd;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface userToFlashlight connect user.onOffCmdPort to flashlight.onOffCmdPort {\n\t\t\tref flow references illuminateRegion.onOffCmdFlow\n\t\t\t\tfrom source.onOffCmd to target.onOffCmd; \n\t\t}\n\t\t\n\t\tpart flashlight {\n\t\t\tport onOffCmdPort: ~OnOffCmdPort;\n\t\t\t\n\t\t\tperform illuminateRegion.produceDirectedLight {\n\t\t\t\tin onOffCmd = onOffCmdPort.onOffCmd;\n\t\t\t\tout light = lightPort.light;\n\t\t\t}\n\t\t\t\n\t\t\tport lightPort: LightPort ;\n\t\t}\n\t\tpart reflectingSource {\n\t\t\tport lightPort: ~LightPort;\n\t\t\t\n\t\t\tperform illuminateRegion.reflectLight {\n\t\t\t\tin light = lightPort.light;\n\t\t\t}\n\t\t}\n\t}\n\t\n\taction illuminateRegion {\n\t\taction sendOnOffCmd { out onOffCmd: OnOffCmd; }\n\t\t\n\t\tsuccession flow onOffCmdFlow from sendOnOffCmd.onOffCmd to produceDirectedLight.onOffCmd;\n\t\t\n\t\taction produceDirectedLight { in onOffCmd; out light: Light; }\n\t\t\n\t\tsuccession flow lightFlow from produceDirectedLight.light to reflectLight.light;\n\t\t\n\t\taction reflectLight { in light: Light; }\n\t}\n\t\n\t\n\t\n}",
        "description": "The SysML-V2 code defines a flashlight system where a user sends on/off commands through a port to a flashlight part, which then produces and directs light based on the command, and a reflecting source part reflects the produced light."
    },
    {
        "code": "package 'Wheel Package - Updated' {\n\tdoc\n\t/*\n\t * Example from the SysML 1.6 spec, subclause 8.4.1 Wheel Hub Assembly.\n\t */\n\n\timport ISQ::*;\n\t\n\t// Quantities\n\t\n\tpressure = force / length^2; \n\t\n\t// Blocks\n\t\n\tpart def WheelHubAssembly;\n\tpart def WheelAssembly {\n\t\tinflationPressure :> pressure;\n\t}\n\t\n\tpart def Tire {\n\t\ttireSpecification : ScalarValues::String;\t\t\n\t\taction mountTire; // Should be operation\n\t}\n\t\n\tpart def TireBead;\n\t\n\tconnection def PressureSeat {\n\t\tend : TireBead[1];\n\t\tend : TireMountingRim[1];\n\t}\n\t\n\tpart def Wheel {\n\t\tdiameter :> length;\n\t\twidth :> length;\t\t\n\t}\n\t\n\tconnection def BandMount {\n\t\tend : Wheel[1];\n\t\tend : WirelessTirePressureMonitor[1];\n\t}\n\t\n\tpart def WirelessTirePressureMonitor {\n\t\taction transmitPressure; // Should be operation\n\t}\n\t\n\tpart def TireMountingRim;\n\t\n\tpart def InflationValve;\n\t\n\tpart def BalanceWeight;\n\t\n\tpart def LugBoltMountingHole {\n\t\tlugBoltSize :> length;\n\t}\n\t\n\tpart def LugBoltJoint {\n\t\ttorque :> ISQ::torque;\n\t\tboltTension :> force;\n\t}\n\t\n\tpart def Hub;\n\t\n\tpart def LugBoltThreadableHole {\n\t\tlugBoltSize :> length;\n\t\tthreadSize :> length;\n\t}\n\t\n\t// Parts\n\t\n\tpart wheelHubAssembly: WheelHubAssembly {\n\t\tpart wheel: WheelAssembly[1] {\n\t\t\tpart t: Tire[1] {\n\t\t\t\tpart bead : TireBead[2];\t\t\t\n\t\t\t}\n\t\t\tpart w: Wheel[1] {\n\t\t\t\tpart rim : TireMountingRim[2];\n\t\t\t\tpart v : InflationValve[1];\n\t\t\t\tpart weight : BalanceWeight[0..6];\n\t\t\t\tpart mountingHoles : LugBoltMountingHole[5];\n\t\t\t}\t\t\t\t\t\t\n\t\t\tconnection : PressureSeat connect t.bead to w.rim;\t\t\n\t\t}\n\t\tpart lugBoltJoints: LugBoltJoint[5] {\t\t\t\t\t\n\t\t\tref mountingHole: LugBoltMountingHole[1] subsets wheel.w.mountingHoles;\n\t\t\tref threadedHole: LugBoltThreadableHole[1] subsets hub.h;\n\t\t}\n\t\tpart hub: Hub[1] {\n\t\t\tpart h: LugBoltThreadableHole[5];\n\t\t}\n\t}\n\t\n}",
        "description": "The SysML-V2 code defines a wheel package with various parts and connections, specifying quantities, blocks, and parts with their respective properties and interactions, such as pressure, dimensions, and assembly relationships."
    },
    {
        "code": "package 'Wheel Package' {\n\tdoc\n\t/*\n\t * Example from the SysML 1.6 spec, subclause 8.4.1 Wheel Hub Assembly.\n\t */\n\n\timport ISQ::*;\n\t\n\tpressure = force / length^2; \n\t\n\tpart def WheelHubAssembly {\n\t\tpart wheel: WheelAssembly[1];\n\t\tpart lugBoltJoints: LugBoltJoint[5] {\n\t\t\tref redefines threadedHole subsets hub.h;\n\t\t\tref redefines mountingHole subsets wheel.w.mountingHoles;\n\t\t}\n\t\tpart hub: Hub[1];\n\t}\n\t\n\tpart def WheelAssembly {\n\t\tinflationPressure :> pressure;\n\t\t\n\t\tpart t: Tire[1] {\n\t\t\tpart bead redefines Tire::bead;\n\t\t}\n\t\tpart w: Wheel[1] {\n\t\t\tpart rim redefines Wheel::rim;\n\t\t}\t\t\n\t\t\t\t\n\t\tconnection : PressureSeat connect t.bead to w.rim;\t\t\n\t}\n\t\n\tpart def Tire {\n\t\ttireSpecification : ScalarValues::String;\n\t\t\n\t\tpart bead : TireBead[2];\n\t\t\n\t\taction mountTire;\n\t}\n\t\n\tpart def TireBead;\n\t\n\tconnection def PressureSeat {\n\t\tend : TireBead[1];\n\t\tend : TireMountingRim[1];\n\t}\n\t\n\tpart def Wheel {\n\t\tdiameter :> length;\n\t\twidth :> length;\n\t\t\n\t\tpart rim : TireMountingRim[2];\n\t\tpart v : InflationValve[1];\n\t\tpart weight : BalanceWeight[0..6];\n\t\tpart mountingHoles : LugBoltMountingHole[5];\n\t}\n\t\n\tconnection def BandMount {\n\t\tend : Wheel[1];\n\t\tend : WirelessTirePressureMonitor[1];\n\t}\n\t\n\tpart def WirelessTirePressureMonitor {\n\t\taction transmitPressure;\n\t}\n\t\n\tpart def TireMountingRim;\n\t\n\tpart def InflationValve;\n\t\n\tpart def BalanceWeight;\n\t\n\tpart def LugBoltMountingHole {\n\t\tlugBoltSize :> length;\n\t}\n\t\n\tpart def LugBoltJoint {\n\t\ttorque :> ISQ::torque;\n\t\tboltTension :> force;\n\t\t\n\t\tref mountingHole: LugBoltMountingHole[1];\n\t\tref threadedHole: LugBoltThreadableHole[1];\n\t}\n\t\n\tpart def Hub {\n\t\tpart h: LugBoltThreadableHole[5];\n\t}\n\t\n\tpart def LugBoltThreadableHole {\n\t\tlugBoltSize :> length;\n\t\tthreadSize :> length;\n\t}\n\t\n}",
        "description": "The SysML-V2 code defines a complex system for a wheel package, detailing parts like WheelHubAssembly, WheelAssembly, Tire, Wheel, and their interactions through connections such as PressureSeat and BandMount, emphasizing structural and functional relationships and constraints."
    },
    {
        "code": "package HSUVDynamics {\n\timport ScalarValues::*;\n\timport SequenceFunctions::size;\n\timport ControlFunctions::*;\n\t\n\tattribute def Horsepwr :> Real;\n\tattribute def Weight :> Real;\n\tattribute def Accel :> Real;\n\tattribute def Vel :> Real;\n\tattribute def Dist :> Real;\n\tattribute def Time :> Real;\n\t\n\tconstraint def PowerEquation {\n\t\tattribute whlpwr : Horsepwr;\n\t\tattribute Cd : Real;\n\t\tattribute Cf : Real;\n\t\tattribute tw : Weight;\n\t\tattribute tp : Horsepwr;\n\t\tattribute v : Vel;\n\t\t\n\t\ttp == whlpwr - Cd * v - Cf * tw * v\n\t}\n\t\n\tconstraint def PositionEquation {\n\t\tattribute dt : Time;\n\t\tattribute v : Vel[0..*] ordered;\n\t\tattribute x : Dist[0..*] ordered;\n\t\t\n\t\t(1..size(x)-1)->forAll {in n : Natural; x#(n + 1) == x#(n) + v#(n) * (5280/3600) * dt}\n\t}\n\t\n\tconstraint def VelocityEquation {\n\t\tattribute dt : Time;\n\t\tattribute v : Vel[0..*] ordered;\n\t\tattribute a : Accel;\n\t\t\n\t\t(1..size(v)-1)->forAll {in n: Natural; v#(n + 1) == v#(n) + a * 32 * (3600/5280) * dt}\n\t}\n\t\n\tconstraint def AccelerationEquation {\n\t\tattribute tw : Weight;\n\t\tattribute dt : Time;\n\t\tattribute tp : Horsepwr;\n\t\tattribute a : Accel;\n\t\t\n\t\ta == (550/32) * tp * dt * tw\n\t}\n\t\n\tconstraint def StraightLineVehicleDynamics {\n\t\tattribute dt : Time;\n\t\tattribute whlpwr : Horsepwr;\n\t\tattribute Cd : Real;\n\t\tattribute Cf: Real;\n\t\tattribute tw : Weight;\n\t\tattribute a : Accel;\n\t\tattribute v : Vel[0..*] ordered;\n\t\tattribute x : Dist[0..*] ordered;\n\t\t\n\t\tconstraint pwr : PowerEquation {\n\t\t\tattribute redefines whlpwr = StraightLineVehicleDynamics::whlpwr;\n\t\t\tattribute redefines Cd = StraightLineVehicleDynamics::Cd;\n\t\t\tattribute redefines Cf = StraightLineVehicleDynamics::Cf;\n\t\t\tattribute redefines tw = StraightLineVehicleDynamics::tw;\n\t\t\tattribute redefines v = vel.v;\n\t\t\tattribute redefines tp;\n\t\t}\n\t\t\n\t\tconstraint acc : AccelerationEquation {\n\t\t\tattribute redefines tp = pwr.tp;\n\t\t\tattribute redefines tw = StraightLineVehicleDynamics::tw;\n\t\t\tattribute redefines dt = StraightLineVehicleDynamics::dt;\n\t\t\tattribute redefines a = StraightLineVehicleDynamics::a;\n\t\t}\n\t\t\n\t\tconstraint vel : VelocityEquation {\n\t\t\tattribute redefines a = acc.a;\n\t\t\tattribute redefines v = StraightLineVehicleDynamics::v;\n\t\t\tattribute redefines dt = StraightLineVehicleDynamics::dt;\n\t\t}\n\t\t\n\t\tconstraint pos : PositionEquation {\n\t\t\tattribute redefines v = vel.v;\n\t\t\tattribute redefines x = StraightLineVehicleDynamics::x;\n\t\t\tattribute redefines dt = StraightLineVehicleDynamics::dt;\n\t\t}\n\t}\n\t\t\n}",
        "description": "The SysML-V2 code defines a model for straight-line vehicle dynamics, including constraints for power, position, velocity, and acceleration equations, with attributes and equations linked through redefinitions for coherent system behavior simulation."
    },
    {
        "code": "package 'Vehicle Decomposition - Updated' {\n\tdoc\n\t/*\n\t * Example from the SysML 1.6 spec, subclause 8.4.5 Constraining Decomposition,\n\t * updated for usage-focused approach.\n\t */\n\t\n\t// Blocks\n\t\n\tpart def Vehicle;\n\t\n\tpart def 'Chassis Assembly';\n\t\n\tpart def Wheel;\n\t\n\tpart def LugBolt;\n\t\n\tpart def RollBar;\n\tpart def HeavyRollBar :> RollBar;\n\tpart def LightRollBar :> RollBar;\n\t\n\tpart def Engine;\n\t\n\tpart def Cylinder;\n\t\n\t// Parts\n\t\n\tpart vehicle : Vehicle {\n\t\tpart chs : 'Chassis Assembly'[1] {\n\t\t\tpart rb : RollBar[0..1];\n\t\t\tpart w : Wheel[4] {\n\t\t\t\tpart lb : LugBolt[6..10];\n\t\t\t}\n\t\t}\n\t\tpart eng: Engine[1] {\n\t\t\tpart cyl : Cylinder[4..8];\n\t\t}\n\t}\n\t\n\t\n\tpart 'vehicle model 1' :> vehicle {\n\t\tpart redefines chs {\n\t\t\tpart redefines rb : LightRollBar[0..1];\n\t\t\tpart redefines w {\n\t\t\t\tpart redefines lb;\n\t\t\t}\n\t\t}\n\t\tpart redefines eng {\n\t\t\tpart redefines cyl[4];\n\t\t}\n\t\t\n\t\t// Constrains total number of lugbolts.\n\t\tref lugBolts[24] = chs.w.lb;\n\t}\n\t\n\tpart 'vehicle model 2' :> vehicle {\n\t\tpart redefines chs {\n\t\t\tpart redefines rb[0];\n\t\t\tpart redefines w {\n\t\t\t\t// Constrains number of lugbolts per wheel.\n\t\t\t\tpart redefines lb[6..7];\n\t\t\t}\n\t\t}\n\t\tpart redefines eng {\n\t\t\tpart redefines cyl[6..8];\n\t\t}\n\t}\n}",
        "description": "The SysML-V2 code defines a vehicle system with various parts and assemblies, allowing for specific constraints and redefinitions in different vehicle models, such as limiting the number of lug bolts and specifying the type of roll bar."
    },
    {
        "code": "package 'Vehicle Decomposition' {\n\tdoc\n\t/*\n\t * Example from the SysML 1.6 spec, subclause 8.4.5 Constraining Decomposition.\n\t */\n\t\n\tpart def Vehicle {\n\t\tpart chs : 'Chassis Assembly'[1] {\n\t\t\tpart rb redefines 'Chassis Assembly'::rb;\n\t\t\tpart redefines w {\n\t\t\t\tpart redefines lb;\n\t\t\t}\n\t\t}\n\t\tpart eng : Engine[1] {\n\t\t\tpart cyl redefines Engine::cyl;\n\t\t}\n\t\t\n\t\tref cylinderBR[*] = eng.cyl;\n\t\tref rollBarBR[*] = chs.rb;\n\t\tref lugBoltBR[24..32] = chs.w.lb;\n\t}\n\t\n\tpart def 'Chassis Assembly' {\n\t\tpart w : Wheel[4];\n\t\tpart rb : RollBar[0..1];\n\t}\n\t\n\tpart def Wheel {\n\t\tpart lb : LugBolt[6..10];\n\t}\n\t\n\tpart def LugBolt;\n\t\n\tpart def RollBar;\n\tpart def HeavyRollBar :> RollBar;\n\tpart def LightRollBar :> RollBar;\n\t\n\tpart def Engine {\n\t\tpart cyl : Cylinder[4..8];\n\t}\n\t\n\tpart def Cylinder;\n\t\n\tpart def 'Vehicle Model 1' :> Vehicle {\n\t\tref redefines cylinderBR[4];\n\t\tref redefines rollBarBR : LightRollBar[*];\n\t\tref redefines lugBoltBR[24];\n\t}\n\t\n\tpart def 'Vehicle Model 2' :> Vehicle {\n\t\tref redefines cylinderBR[6..8];\n\t\tref redefines rollBarBR[0];\n\t\tref redefines lugBoltBR[24..28]; // 6..7 per wheel\n\t}\n}",
        "description": "The SysML-V2 code defines a hierarchical decomposition of a vehicle system, detailing its parts such as chassis, engine, wheels, and their respective components, and specifies constraints and redefinitions for different vehicle models."
    },
    {
        "code": "package SimpleQuadcopter {\n    import ISQ::*;\n    import SI::*;\n    import SpatialItems::*;\n    import ShapeItems::*;\n    import RealFunctions::sqrt;\n    import TrigFunctions::pi;\n    import TrigFunctions::tan;\n    import MeasurementReferences::CoordinateFrame;\n    import MeasurementReferences::TranslationRotationSequence;\n    import MeasurementReferences::Translation;\n    import MeasurementReferences::Rotation;\n\n    part motorShape : SpatialItem {\n        item :>> shape : Cylinder {\n            :>> radius = 18 [mm];\n            :>> height = 30 [mm];\n        }\n    }\n    \n    part def Strut :> SpatialItem {\n        // By default will get same coordinateFrame.mRefs as owning SpatialItem, i.e.:\n        // attribute :>> coordinateFrame { :>> mRefs = (mm, mm, mm); }\n        \n        /* rawStrut is a construction shape: a rectangular beam */\n        part rawStrut : SpatialItem {\n            item :>> shape : Box {\n                :>> length = 160 [mm];\n                :>> width = 15 [mm];\n                :>> height = 8 [mm];\n            }\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (0, shape.width/2, 0)[source]));\n                }\n            }        \n        }\n\n        /* motorCutout is a construction shape: a cylinder of the same shape as the  */\n        part motorCutout : SpatialItem {\n            item :>> shape = motorShape.shape;\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (175, 0, -1)[source]));\n                }\n            }\n        }\n        \n        /* Strut shape is CSG difference of rawStrut minus motorCutout */\n        attribute :> differencesOf[1] {\n            item :>> elements = (rawStrut, motorCutout);\n        }        \n    }\n    \n    part def PropellerMotorAssy :> SpatialItem {\n        // By default will get same coordinateFrame.mRefs as owning CompoundSpatialItem, i.e.:\n        // attribute :>> coordinateFrame { :>> mRefs = (mm, mm, mm); }\n\n        part propeller : SpatialItem {\n            item :>> shape : Cylinder {\n                doc /* propeller stay-out volume, without propeller shaft */\n                :>> radius = 80 [mm];\n                :>> height = 6 [mm];\n            }\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (175, 0, 31)[source]));\n                }\n            }\n        }\n\n        part motor : SpatialItem {\n            item :>> shape = motorShape.shape;\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (175, 0, 0)[source]));\n                }\n            }\n        }\n        \n        // By default the shape of a PropellerMotorAssy is the union of its owned composite items and parts that are SpatialItems.\n    }\n\n    part def Camera :> SpatialItem {\n        // By default will get same coordinateFrame.mRefs as owning CompoundSpatialItem, i.e.:\n        // attribute :>> coordinateFrame { :>> mRefs = (mm, mm, mm); }\n\n        part cameraHousing : SpatialItem {\n            item :>> shape : Cylinder {\n                :>> radius = 15 [mm];\n                :>> height = 24 [mm];\n            }\n        }\n\n        /* The field of view is modeled as an item, since it is not a part of the quadcopter but rather a stay-out volume \n         * that can for example be used to formulate a constraint.\n         */\n        item fieldOfView : SpatialItem {\n            doc /* Conical field of view with half-top angle 20 degree */\n            item :>> shape : Cone {\n                :>> radius = height * tan(20 * pi/180) [mm];\n                :>> height = 500 [mm];\n            }\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Rotation( (0, 1, 0)[source], 180['\u00b0']));\n                }\n            }\n        }\n        \n        // By default the shape of a Camera is the union of its owned composite items and parts that are SpatialItems.\n    }\n\n    part quadCopter : SpatialItem {\n        attribute datum :>> coordinateFrame {\n            doc /* The datum is the top level coordinate frame of the system-of-interest, i.e., the quadcopter.\n                 * By convention its origin is placed at the bottom of the mainBody with the +X axis pointing in the \n                 * forward fligth (velocity) direction and the +Z axis pointing upward. The +Y axis completes the \n                 * right-handed Cartesian coordinate system.\n                 */\n            :>> mRefs = (mm, mm, mm);\n        }\n\n        part mainBody : SpatialItem {\n\n            /* rawBody is a construction shape: the enveloping rectangular box */\n            part rawBody : SpatialItem {\n                item :>> shape : Box {\n                    :>> length = 160 [mm];\n                    :>> width = 15 [mm];\n                    :>> height = 8 [mm];\n                }\n                attribute :>> coordinateFrame {\n                    :>> transformation : TranslationRotationSequence {\n                        :>> elements = (Translation( (0, shape.width/2, 0)[source]));\n                    }\n                }        \n            }\n            \n            /* cuttingBox is a construction shape: the enveloping rectangular box */\n            part cuttingCornersBox : SpatialItem {\n                item :>> shape : Box {\n                    :>> length = 105 [mm];\n                    :>> width = 105 [mm];\n                    :>> height = 60 [mm];\n                }\n                attribute :>> coordinateFrame {\n                    :>> transformation : TranslationRotationSequence {\n                        :>> elements = (Translation( (0, -shape.length/sqrt(2), -10)[source]), \n                                        Rotation((0, 0, 1)[source], 45['\u00b0']));\n                    }\n                }        \n            }\n\n            /* Main body shape is the CSG intersection of rawBody and cuttingCornersBox */\n            attribute :> intersectionsOf[1] {\n                item :>> elements = (rawBody, cuttingCornersBox);\n            }\n            // Current syntax is not end-user friendly\n            // It will be possible to specify following simple CSG expression:\n            // item :>> shape = rawBody & cuttingCornersBox;\n        }\n\n        // Helper construction parameters\n        private attribute xStrut : LengthValue = 49.60[mm];\n        private attribute yStrut : LengthValue = 24.65[mm];\n        private attribute zStrut : LengthValue = 25[mm];\n        private attribute zPMAssy : LengthValue = 12[mm];\n\n        part strut1 : Strut {\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (xStrut.num, yStrut.num, zStrut.num)[source]), \n                                    Rotation((0, 0, 1)[source], 45['\u00b0']));\n                }\n            }        \n        }\n        part strut2 : Strut {\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (-xStrut.num, yStrut.num, zStrut.num)[source]), \n                                    Rotation((0, 0, 1)[source], 135['\u00b0']));\n                }\n            }        \n        }\n        part strut3 : Strut {\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (-xStrut.num, -yStrut.num, zStrut.num)[source]), \n                                    Rotation((0, 0, 1)[source], 225['\u00b0']));\n                }\n            }        \n        }\n        part strut4 : Strut {\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (xStrut.num, -yStrut.num, zStrut.num)[source]), \n                                    Rotation((0, 0, 1)[source], 315['\u00b0']));\n                }\n            }        \n        }\n\n        part propellerMotorAssy1 : PropellerMotorAssy {\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (xStrut.num, yStrut.num, zPMAssy.num)[source]), \n                                    Rotation((0, 0, 1)[source], 45['\u00b0']));\n                }\n            }        \n        }\n        part propellerMotorAssy2 : PropellerMotorAssy {\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (-xStrut.num, yStrut.num, zPMAssy.num)[source]), \n                                    Rotation((0, 0, 1)[source], 135['\u00b0']));\n                }\n            }        \n        }\n        part propellerMotorAssy3 : PropellerMotorAssy {\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (-xStrut.num, -yStrut.num, zPMAssy.num)[source]), \n                                    Rotation((0, 0, 1)[source], 225['\u00b0']));\n                }\n            }        \n        }\n        part propellerMotorAssy4 : PropellerMotorAssy {\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (xStrut.num, -yStrut.num, zPMAssy.num)[source]), \n                                    Rotation((0, 0, 1)[source], 315['\u00b0']));\n                }\n            }        \n        }\n\n        /* The camera is placed protruding from the +X face of the main body, rotated about the +Y axis over 50\u00b0 downwards */\n        part camera : Camera {\n            attribute :>> coordinateFrame {\n                :>> transformation : TranslationRotationSequence {\n                    :>> elements = (Translation( (59, 0, 2)[source]), \n                                    Rotation((0, 1, 0)[source], 50['\u00b0']));\n                }\n            }        \n        }\n        \n    }\n}",
        "description": "The SysML-V2 code defines a detailed model of a simple quadcopter, including its spatial components like motors, struts, propeller-motor assemblies, and a camera, using geometric shapes and transformations to specify their positions and orientations within a coordinate frame."
    },
    {
        "code": "package CarWithEnvelopingShape {\n\timport ShapeItems::Box;\n\timport SI::mm;\n\n\tpart def Car {\n\t\tdoc\n\t\t/*\n\t\t * Example car with simple enveloping shape that is a solid box\n\t\t */\n\t\n\t\titem boundingBox : Box [1] :> boundingShapes {\n\t\t\t:>> length = 4800 [mm];\n\t\t\t:>> width  = 1840 [mm];\n\t\t\t:>> height = 1350 [mm];\n\t\t}\n\t}\n}",
        "description": "The SysML-V2 code defines a car part with an enveloping shape represented by a bounding box, specifying its dimensions in millimeters."
    },
    {
        "code": "package ExternalShapeRefExample {\n\timport ScalarValues::String;\n\timport ShapeItems::*;\n\timport ISQ::mass;\n\timport SI::mm;\n\n\tmetadata def ExternalShapeRef {\n\t\tdoc\n\t\t/*\n\t\t * Metadata to reference an externally defined shape.\n\t\t */\n\t\n\t\tattribute purpose : String[1];\n\t\tattribute shapeIri : String[1];\n\t}\n\t\n\tpart myBatteryUnit {\n\t    item :>> shape : Shell {\n\t\t\tmetadata ExternalShapeRef {\n\t\t\t\tpurpose = \"highLoD\";\n\t\t\t\tshapeIri = \"file:/detailed-geometry/LEMS-250W_BatteryHousing_Example.step\";\n\t\t\t}\n\t\t}\t\t\n\n\t\tprivate item envelopingBoxBatteryUnit : Box :> envelopingShapes {\n\t\t\t:>> length = 140[mm];\n\t\t\t:>> width = 148[mm];\n\t\t\t:>> height = 90[mm];\n\t\t}\n\t}\n}",
        "description": "The SysML-V2 code defines a metadata structure for referencing external shapes and demonstrates its usage within a part definition, including a shape reference and an enveloping box with specified dimensions."
    },
    {
        "code": "package VehicleGeometryAndCoordinateFrames {\n    import TrigFunctions::*;\n    import ISQ::*;\n\timport SI::*;\n\timport Time::*;\n\n    import ShapeItems::*;\n    import SpatialItems::*;\n\n    import MeasurementReferences::CoordinateFrame;\n    import MeasurementReferences::TranslationRotationSequence;\n    import MeasurementReferences::Translation;\n    import MeasurementReferences::Rotation;\n    \n    private import Collections::Array;\n    private import ScalarValues::Boolean;\n    private import ScalarValues::Real;\n    private import ScalarValues::Natural;\n\tprivate import ControlFunctions::forAll;\n    \n    part def Vehicle :> SpatialItem;\n\n    part def Chassis :> SpatialItem {\n        item :>> shape = Box(4800 [mm], 1840 [mm], 1350 [mm]);\n    }\n\n    part def Wheel :> SpatialItem {\n\t\tdoc\n\t\t/*\n\t\t * Generic wheel with lugbolts\n\t\t * \n\t\t * The radius is estimated for a 22 inch hub plus 110 mm tire height.\n\t\t * The wheel width is equal to the cylinder height.\n\t\t * The wheel has 5 lugbolts that are evenly distributed along a circle centered at the wheel's center.\n\t\t */\n\t\n    \tref item :>> self : Wheel;\n        item :>> shape : Cylinder {\n            :>> radius = 22/2*25.4 + 110 [mm]; \n            :>> height = 220 [mm];\n        }\n        attribute <wcf> wheelCoordinateFrame : CoordinateFrame;\n        \n        attribute numberOfBolts : Natural = 5;\t\n\t\tpart lugBolts : LugBolt[1..numberOfBolts];\n\t\t\n\t\t/* \n\t\t * As an example of a more involved placement of composite parts, constrain the positions of the coordinate frame origins \n\t\t * of the lugbolts to a circle with radius lbpr distributed evenly over 360\u00b0.\n\t\t */\n        attribute <lbpr> lugBoltPlacementRadius :>> radius default 60 [mm];\n\t\tprivate attribute lugBoltDistributionAngle :>> planeAngle = 360/numberOfBolts ['\u00b0'];\n        private attribute lbda : Real = lugBoltDistributionAngle.num * (pi/180); // lugBoltDistributionAngle in radian\n\t\tassert constraint {\n\t\t\t(1..numberOfBolts)->forAll {\n\t\t\t\tin i : Natural;\n\t\t\t\tprivate attribute lbcf = lugBolts#(i).coordinateFrame; \n\t\t\t\tprivate attribute trs : TranslationRotationSequence {\n\t\t\t\t\t:>> source = wcf;\n\t\t\t\t\t:>> target = lbcf;\n\t\t\t\t\t:>> elements = Translation((lbpr*cos((i-1)*lbda), lbpr*sin((i-1)*lbda), -8)[wcf]); \n\t\t\t\t}\n\t\t\t\tlbcf.transformation == trs\n\t\t\t}\n\t\t}\n    }\n\n    part def LugBolt :> SpatialItem {\n    \titem :>> shape : Cylinder {\n    \t\t:>> radius = 14 [mm];\n    \t\t:>> height = 40 [mm];\n    \t}\n    }\n\n    part vehicle : Vehicle, SpatialItem {\n\t\t/* \n\t\t * Vehicle frame origin at center of bottom plate of chassis\n\t\t * with +Z upwards and +X in the forward (front) direction\n\t\t */\n        attribute datum :>> coordinateFrame {\n            :>> mRefs = (mm, mm, mm);\n        }\n\n        part chassis : Chassis[1] :> componentItems {\n\t\t\tattribute :>> coordinateFrame {\n\t\t\t\tattribute :>> transformation : TranslationRotationSequence {\n\t \t          \tattribute :>> source = datum;\n                \tattribute :>> elements = Translation((-(shape as Box).length/2, -(shape as Box).width/2, 0)[datum]);\n                }\n\t\t\t}\n        }\n\n        private attribute plusXAxis : Array { :>> dimensions = 3; :>> elements : Real[3] = (1, 0, 0); }\n        private attribute frontWheelXShift : Real = 1670;\n        private attribute rearWheelXShift : Real = -1820;\n        private attribute wheelYShift : Real = 720;\n\n        part leftFrontWheel : Wheel[1] :> componentItems {\n            attribute :>> coordinateFrame {\n                attribute :>> transformation : TranslationRotationSequence {\n\t            \tattribute :>> source = datum;\n                \tattribute :>> elements = (Translation((frontWheelXShift, wheelYShift, 80)[datum]), Rotation(plusXAxis[datum], -90['\u00b0']));\n                }\n            }\n        }\n        part rightFrontWheel : Wheel[1] :> componentItems {\n            attribute :>> coordinateFrame {\n                attribute :>> transformation : TranslationRotationSequence {\n                \tattribute :>> source = datum;\n                \tattribute :>> elements = (Translation((frontWheelXShift, -wheelYShift, 80)[datum]), Rotation((1, 0, 0)[datum], 90['\u00b0']));\n                }\n            }\n        }\n        part leftRearWheel : Wheel[1] :> componentItems {\n            attribute :>> coordinateFrame {\n                attribute :>> transformation : TranslationRotationSequence {\n                \tattribute :>> source = datum;\n                \tattribute :>> elements = (Translation((rearWheelXShift, wheelYShift, 80)[datum]), Rotation((1, 0, 0)[datum], 90['\u00b0']));\n                }\n            }\n        }\n        part rightRearWheel : Wheel[1] :> componentItems {\n            attribute :>> coordinateFrame {\n                attribute :>> transformation : TranslationRotationSequence {\n\t\t\t\t\tattribute :>> source = datum;\n                \tattribute :>> elements = (Translation((rearWheelXShift, -wheelYShift, 80)[datum]), Rotation((-1, 0, 0)[datum], 90['\u00b0']));\n                }\n            }\n        }\n    }\n}\n",
        "description": "The SysML-V2 code defines a vehicle system with parts like Vehicle, Chassis, and Wheel, specifying their shapes, coordinate frames, and spatial relationships, including the placement of lug bolts and wheel positions relative to the chassis."
    },
    {
        "code": "package CarWithShapeAndCSG {\n\timport SpatialItems::*;\n    import ShapeItems::*;\n    import Objects::Point;\n\timport Quantities::VectorQuantityValue;\n\timport MeasurementReferences::CoordinateFrame;\n\timport MeasurementReferences::TranslationRotationSequence;\n\timport MeasurementReferences::Translation;\n\timport MeasurementReferences::Rotation;\n\timport SI::*;\n\n\tpart def Car :> SpatialItem {\n\t\tdoc\n\t\t/*\n\t\t * Car with simple engine\n\t\t */\n\t\n        item :>> shape = Cuboid(4800 [mm], 1840 [mm], 1350 [mm]);\n\n        attribute datum :>> coordinateFrame {\n            :>> mRefs = (mm, mm, mm);\n        }\n\n\t\tpart powerSource : Engine [1] :> componentItems {\n\t\t\t:>> ecf { \n\t\t\t\t:>> mRefs = datum.mRefs;\n\t\t\t\t:>> transformation : TranslationRotationSequence {\n\t\t\t\t\t:>> source = datum;\n\t\t\t\t\t:>> elements = ( Translation((3800, (1840-190)/2, 40)[datum]) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpart def Engine :> SpatialItem {\n\t\tdoc\n\t\t/*\n\t\t * Simple 2-cylinder engine\n\t\t * \n\t\t * Note: The engine shape is modeled as a rectangular box with two cylindrical holes, a gross simplification.\n\t\t */\n\t\n\t\titem :>> shape [1];\n\t\t\n\t\tattribute <ecf> engineCoordinateFrame :>> coordinateFrame;\t\t\n\n\t\tpart rawEngineBlock : SpatialItem [1] {\n\t\t\titem :>> shape : Box [1] {\n\t    \t\t:>> length = 300 [mm];\n\t    \t\t:>> width = 190 [mm];\n\t    \t\t:>> height = 330 [mm];\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate attribute rearCylinderSpacing = 90 [mm];\n\t\tprivate item cylinder1 : SpatialItem [1] {\n\t\t\titem :>> shape : Cylinder [1] {\n\t    \t\t:>> radius = 55 [mm];\n\t    \t\t:>> height = 350 [mm];\n\t\t\t}\n\t\t\tattribute :>> coordinateFrame {\n\t\t\t\t:>> transformation : TranslationRotationSequence {\n\t\t\t\t\t:>> source = ecf;\n\t\t\t\t\t:>> elements = (Translation( (rearCylinderSpacing, rawEngineBlock.shape.width/2, -10)[ecf]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate attribute cylinderSpacing = 2*cylinder1.shape.radius + 20 [mm];\n\t\tprivate item cylinder2 : SpatialItem [1] {\n\t\t\titem :>> shape : Cylinder [1] {\n\t    \t\t:>> radius = cylinder1.shape.radius;\n\t    \t\t:>> height = cylinder1.shape.height;\n\t\t\t}\n\t\t\tattribute :>> coordinateFrame {\n\t\t\t\t:>> transformation : TranslationRotationSequence {\n\t\t\t\t\t:>> source = ecf;\n\t\t\t\t\t:>> elements = ( Translation((rearCylinderSpacing + cylinderSpacing, rawEngineBlock.shape.width/2, -10)[ecf]) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* CSG difference of rawEngineBlock minus cylinder1 minus cylinder2 */\n\t\tattribute :> differencesOf[1] {\n\t\t\titem :>> elements = (rawEngineBlock, cylinder1, cylinder2);\n\t\t}\n\t}\n}",
        "description": "The SysML-V2 code defines a simplified car model with a spatial representation, including a cuboid shape for the car and a detailed engine model with coordinate frames and transformations for positioning components like the engine block and cylinders using Constructive Solid Geometry (CSG) operations."
    },
    {
        "code": "package Packets {\n\tprivate import ScalarValues::*;\n\tprivate import Time::DateTime;\n\t\n\tattribute 'packet header' { }\n\t\n\tattribute 'packet data field' {\t\n\t\tattribute 'packet secondary header' redefines 'packet header';\n\t\tattribute 'user data field';\n\t}\n\t\n\tpart def 'Data Packet' {\n\t\tattribute 'packet primary header' redefines 'packet header' {\n\t\t\tattribute 'packet version number': Integer;\n\t\t\tattribute 'packet identification': String;\n\t\t\tattribute 'packet data length': Integer;\n\t\t}\n\t\tattribute redefines 'packet data field';\n\t}\n\t\n\tpart def 'Thermal Data Packet' :> 'Data Packet' {\n\t\tattribute 'packet data field' redefines Packets::'packet data field'{\n\t\t\tattribute 'packet secondary header' redefines 'packet header' {\n\t\t\t\tattribute 'packet timestamp': DateTime;\n\t\t\t\tattribute 'telemetry packet type': String;\n\t\t\t}\n\t\t\t\n\t\t\tattribute 'user data field' redefines Packets::'packet data field'::'user data field' {\n\t\t\t\tattribute timestamp: DateTime;\n\t\t\t\tattribute temperature: Real;\n\t\t\t}\n\t\t}\n\t}\n\t\n}",
        "description": "The SysML-V2 code defines a hierarchical structure for data packets, including a base 'Data Packet' with primary and secondary headers, and a specialized 'Thermal Data Packet' that inherits from 'Data Packet' and includes additional attributes for timestamp and temperature data."
    },
    {
        "code": "package 'Packet Usage' {\n\tpublic import Packets::*;\n\tprivate import ScalarValues::Real;\n\t\n\tpart packet1: 'Thermal Data Packet';\n\tpart packet2: 'Thermal Data Packet';\n\tpart packet3: 'Thermal Data Packet' {\n\t\tattribute 'special data field' redefines 'packet data field'{\n\t\t\tattribute redefines 'user data field' {\n\t\t\t\tattribute 'special data': Real;\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\t\n",
        "description": "The SysML-V2 code defines a package for packet usage, importing necessary types, and declares multiple instances of a 'Thermal Data Packet' with specific redefinitions of attributes for one instance to handle 'special data' as a real number."
    },
    {
        "code": "// ** This is the Norwegian use-case for Arrowhead Framework */\npackage AHFNorwaySequences {\n\t// Here we show sequences of the Norwegian use-case\n\timport AHFProfileLib::*;\n\timport AHFCoreLib::*;\n\timport AHFNorway::*;\n\timport ScalarValues::*;\n\t\n\tpart AHFN_LocalCloudDD_Seqs = AHFNorway_LocalCloudDD{\n\t\toccurrence def APIS_transfer_lifetime {\t\t\t\n\t\t\t// lifetime orderings \n\t\t\tref part tlc = AHFNorway_LocalCloudDD.TellUConsumer{\n\t\t\t\tevent occurrence call_getItems1;\n\t\t\t\tthen event occurrence return_getItems1;\n\t\t\t\tevent occurrence call_getItems2;\n\t\t\t\tthen event occurrence return_getItems2;\n\t\t\t}\n\t\t\tref part apsp = AHFNorway_LocalCloudDD.APISProducer{\n\t\t\t\tevent occurrence send_publish_returnallitems;\n\t\t\t\tthen event occurrence receive_call_getItems1;\n\t\t\t\tthen event occurrence send_returnallitems1;\n\t\t\t\tthen event occurrence return_getItems_ack1;\n\t\t\t\tthen event occurrence receive_call_getItems2;\n\t\t\t\tthen event occurrence send_returnallitems2;\n\t\t\t\tthen event occurrence return_getItems_ack2;\n\t\t\t}\n\t\t\tref part mqtts = AHFNorway_LocalCloudDD.MQTTServer{\n\t\t\t\tevent occurrence receive_publish_returnallitems;\n\t\t\t\tthen event occurrence receive_subscribe_returnallitems;\n\t\t\t\tthen event forw1:MQTTforwarding;\n\t\t\t\tthen event forw2:MQTTforwarding;\n\t\t\t}\n\t\t\tref part apsc = AHFNorway_LocalCloudDD.APISConsumer{\n\t\t\t\tevent occurrence send_subscribe_returnallitems;\n\t\t\t\tthen event forw1:MQTTforwarding;\n\t\t\t\tthen event forw2:MQTTforwarding;\n\t\t\t}\n\t\t\toccurrence forw1:MQTTforwarding;\t\n\t\t\toccurrence forw2:MQTTforwarding;\t\n\n\t\t\tmessage publish_returnallitems of Publish\n\t\t\tfrom apsp.send_publish_returnallitems to mqtts.receive_publish_returnallitems;\n\t\t\tmessage subscribe_returnallitems of Subscribe\n\t\t\tfrom apsc.send_subscribe_returnallitems to mqtts.receive_subscribe_returnallitems;\n\t\t\tmessage call_getItems1 of CallGiveItems[1]\n\t\t\tfrom tlc.call_getItems1 to apsp.receive_call_getItems1;\t\n\t\t\tbind apsp.send_returnallitems1 = forw1.mq; // binding the sending to the actual gate\n\t\t\t/* How to express that this event sends a Return_AllItems? */\n\t\t\tmessage returnack1 of ResultGiveItems\n\t\t\tfrom apsp.return_getItems_ack1 to tlc.return_getItems1;\n\t\t\tmessage call_getItems2 of CallGiveItems[1]\n\t\t\tfrom tlc.call_getItems2 to apsp.receive_call_getItems2;\n\t\t\tbind apsp.send_returnallitems2 = forw2.mq; // binding the sending to the actual gate\n\t\t\tmessage returnack2 of ResultGiveItems\n\t\t\tfrom apsp.return_getItems_ack2 to tlc.return_getItems2;\n\t\t}\n\n\t\toccurrence def MQTTforwarding {\n\t\t\tref part mqttsf = AHFNorway_LocalCloudDD.MQTTServer{\n\t\t\t\tevent occurrence receive_returnallitems;\n\t\t\t\tthen event occurrence send_returnallitems;\n\t\t\t}\n\n\t\t\tref part apscf :> AHFNorway_LocalCloudDD.APISConsumer {\n\t\t\t\tevent occurrence receive_returnallitems;\n\t\t\t}\n\n\t\t\tin event occurrence mq; // parameter for gate\n\n\t\t\tmessage sendallitems1 of Return_AllItems\n\t\t\tfrom mq to mqttsf.receive_returnallitems;\n\t\t\tmessage sendallitems2 of Return_AllItems\n\t\t\tfrom mqttsf.send_returnallitems to apscf.receive_returnallitems;\n\t\t}\n\n\t\t\n\t\tinterface APIS_transfer_interface : Interfaces::Interface connect (\n\t\t\ttlu ::> AHFNorway_LocalCloudDD.TellUConsumer.apisp.APIS_HTTP, // port reference\n\t\t    apsph ::> AHFNorway_LocalCloudDD.APISProducer.tellu.APIS_HTTP, \n\t\t\tapspm ::> AHFNorway_LocalCloudDD.APISProducer.apisc.APIS_MQTT,\n\t\t\tapsc ::> AHFNorway_LocalCloudDD.APISConsumer.apisp.APIS_MQTT,\n\t\t\tmqget ::> AHFNorway_LocalCloudDD.MQTTServer.getTopic,\n\t\t\tmqgive ::> AHFNorway_LocalCloudDD.MQTTServer.giveTopic) {\n\t\t\t\n\t\t\tmessage publish_returnallitems of Publish\n\t\t\tfrom apspm to mqget;\n\t\t\tmessage subscribe_returnallitems of Subscribe\n\t\t\tfrom apsc to mqgive;\n\t\t\tmessage call_getItems of CallGiveItems[1]\n\t\t\tfrom tlu to apsph;\n\t\t\tmessage returnallitems of Return_AllItems\n\t\t\tfrom apspm to mqget;\n\t\t\tmessage sendallitems of Return_AllItems\n\t\t\tfrom mqgive to apsc;\n\t\t\tmessage returnack of ResultGiveItems\n\t\t\tfrom apsph to tlu;\n\t\t\t\n\t\t\t// Successions on each lifetime\n\t\t\t// tlu\n\t\t\tsuccession first call_getItems.startShot\n\t\t\tthen returnack.endShot;\t\n\t\t\t// apisp (taking both ports)\n\t\t\tsuccession first publish_returnallitems.startShot\n\t\t\tthen call_getItems.endShot;\n\t\t\tsuccession first call_getItems.endShot\n\t\t\tthen returnallitems.startShot;\n\t\t\tsuccession first returnallitems.startShot\n\t\t\tthen returnack.startShot;\n\t\t\t// MQTTServer\n\t\t\tsuccession first publish_returnallitems.endShot\n\t\t\tthen subscribe_returnallitems.endShot;\n\t\t\tsuccession first subscribe_returnallitems\n\t\t\tthen returnallitems.endShot;\n\t\t\tsuccession first returnallitems.endShot\n\t\t\tthen sendallitems.startShot;\n\t\t\t// apisc\n\t\t\tsuccession first subscribe_returnallitems.startShot\n\t\t\tthen sendallitems.endShot;\n\t\t}\n\t\t\n\t}\n}",
        "description": "The SysML-V2 code defines a sequence of interactions in the Norwegian use-case for the Arrowhead Framework, detailing the messaging and event occurrences between components like TellUConsumer, APISProducer, MQTTServer, and APISConsumer, along with the interface connections and message flows between them."
    },
    {
        "code": "library package AHFProfileLib {\n\t// Systems and Services and their functionalities\n\timport ScalarValues::*;\n\t\n\t// Design level\n\tport def SD{\n\t\tdoc /* Service definition */\n\t\t\n\t\tattribute serviceDefinition:String;\n\t\tattribute serviceURL:String;\n\t\tattribute intrfce_protocol:String; // which may be \"REST\" or \"MQTT\" etc.\t\t \n\t}\t\n\t\t\n\tpart def SysLocalCloudsDesign {\n\t\tdoc /* System of Systems Definition */\t\n\n\t\t// System of Local Clouds \n\t\tpart locclouds:LocalCloudDesign[1..*];\n\t}\n\t\n\tpart system_of_systems:SysLocalCloudsDD; // defining a top level usage\n\t\n\tpart def LocalCloudDesign {\n\t\tdoc /* Local Cloud definition */\n\n\t\tpart systems:SysD[1..*];\t\n\t}\n\n\tpart def SysD {\n\t\tdoc /* System definitions */\t\n\n\t\tport services: SD[1..*];\n\t\tattribute systemname: String;\n\t\tattribute address: String;\n\t\tattribute portno: Integer;\n\t}\t\n\n\t// Design Description level\n\tport def IDD :> SD{\n\t\tdoc /* Interface Design Description of services */\n\t\t\n\t\tattribute encoding_kind:String;\n\t}\n\t\n\tport def SDDD :> SD{\n\t\tdoc /* Service Definition Design Description */\n\t\t\n\t\tport idds:IDD[*]; // nested protocol-specific services\n\t}\t\n\n\tpart def SysLocalCloudsDD :> SysLocalCloudsDesign {\n\t\tdoc /* System of Systems Detailed Description */\t\n\n\t\tpart :>> locclouds:LocalCloudDD[1..*]; // the descriptions\n\t}\n\n\tpart def LocalCloudDD :> LocalCloudDesign {\n\t\tpart :>> systems:SysDD[1..*];\n\t}\n\n\tpart def SysDD :> SysD{\n\t\tdoc /* System Detailed Description */\n\n\t\tport :>> services:SDDD;\n\t\taction ServiceMethod[1..*]; //means general behaviors\n\t}\n}\n\nlibrary package AHFProfileMetadata{\n\timport Metaobjects::SemanticMetadata;\n\timport AHFProfileLib::*;\n\n\tport global_sd:SD;\n\tmetadata def <service> SDMetadata :> SemanticMetadata{\n\t\t// :>> baseType = system_of_systems.locclouds.systems.services meta SysML::PortUsage;\n\t\t// :>> baseType = SysD::services meta SysML::PortUsage;\n\t\t:>> baseType default global_sd meta SysML::PortUsage;\n\t}\n\t\n\tmetadata def <sos> SysLocalCloudsMetadata :> SemanticMetadata{\n\t\t:>> baseType = system_of_systems meta SysML::PartUsage;\n\t}\n\t\n\tmetadata def <cloud> LocalCloudsMetadata :> SemanticMetadata{\n\t\t:>> baseType default system_of_systems::locclouds meta SysML::PartUsage;\n\t}\n\t\n\tmetadata def <system> SysDMetadata :> SemanticMetadata{\n\t\t:>> baseType default system_of_systems::locclouds::systems meta SysML::PartUsage;\n\t\t// :>> baseType default LocalCloudDesign::systems meta SysML::PartUsage;\n\t}\n\n\tmetadata def <idd> IDDMetadata :> SDMetadata{\n\t\t// :>> baseType = system_of_systems.locclouds.systems.services.idd meta SysML::PortUsage;\n\t\t:>> baseType = SDDD::idds meta SysML::PortUsage;\n\t\t// :>> global_sddd.idd;\n\t}\n\n\tport global_sddd:SDDD;\n\tmetadata def <servicedd> SDDDMetadata :> SDMetadata {\n\t\t// :>> baseType = system_of_systems.locclouds.systems.services meta SysML::PortUsage;\n\t\t:>> baseType = global_sddd meta SysML::PortUsage;\n\t}\n\t\n\tmetadata def <clouddd> LocalCloudsDDMetadata :> LocalCloudsMetadata{\n\t\t:>> baseType = system_of_systems::locclouds meta SysML::PartUsage;\n\t}\n\t\n\tpart global_clouddd:LocalCloudDD;\n\tpart global_systemsdd:SysDD;\n\tmetadata def <systemdd> SysDDMetadata :> SysDMetadata{\n\t\t// :>> baseType = system_of_systems.locclouds.systems meta SysML::PartUsage;\n\t\t//:>> baseType = LocalCloudDD::systems meta SysML::PartUsage;\n\t\t:>> baseType = global_systemsdd meta SysML::PartUsage;\n\t}\t\n\t\n}",
        "description": "The SysML-V2 code defines a hierarchical structure for systems and services, detailing their interactions through ports and parts, and incorporates metadata for semantic annotations and detailed descriptions of system components and service interfaces."
    },
    {
        "code": "// /** Mandatory Services and Systems */\nlibrary package AHFCoreLib {\n\timport AHFProfileLib::*;\n\timport ScalarValues::*;\n\timport AHFProfileMetadata::*;\n\n\t#service port def ServiceDiscovery {\n\t\t// The functionalities as Requests (Operations) cannot be defined yet\n\t\t// We could consider using flows to designate the functionalities\n\t}\n\t\n\t#service port def ServiceDiscoveryDD :> ServiceDiscovery{\n\t}\n\t\t\n\t#service port def Authorisation {\n\t\tattribute publickey:String; // just as examples\n\t}\n\n\t#service port def AuthorisationDD :> Authorisation{\n\t}\n\n\t\n\t#clouddd ArrowheadCore{\n\t\t// /** Design Level */\n\t\t// First the system definitions (SysD) of core systems\n\t\t\n\t\t#system service_registry {\n\t\t\t#service serviceDiscovery : ServiceDiscovery ;\n\t\t}\n\t\t\n\t\t#system authorization{\n\t\t\t#service authorisation : Authorisation;\n\t\t\tattribute protocol:String = \"HTTP\";\n\t\t}\n\t\t\n\t\t#system orchestrationDesign; // just indicated for now\n\t\t\n\t\t// /** Design Description level */\t\t\n\t\t#systemdd service_registry_DD :> service_registry{\n\t\t\t#servicedd :>> serviceDiscovery:ServiceDiscoveryDD {\n\t\t\t\t#idd serviceDiscovery_HTTP ;// nested port for HTTP protocol\n\t\t\t\t// here we refer the functionalities like operation Register etc.\n\t\t\t\t#idd serviceDiscovery_MQTT ; // nested port for MQTT protocol\n\t\t\t}\n\t\t}\n\t\t\n\t\t#systemdd authorization_DD :> authorization{\n\t\t\t#servicedd :>> authorisation {\n\t\t\t\t#idd authorisation_HTTP ; // nested port for HTTP protocol\n\t\t\t\t#idd authorisation_MQTT ; // nested port for MQTT protocol\n\t\t\t}\n\t\t\taction Echo_behavior :> ServiceMethod;\n\t\t}\n\t}\n}",
        "description": "The SysML-V2 code defines a library package for Arrowhead Framework core services, including service discovery and authorization, with system and service ports, and specifies their design details and protocol implementations."
    },
    {
        "code": "package AHFNorway {\n\tdoc /* This is the Norwegian use-case for Arrowhead Framework */\n\t// The use-case is for Productive4.0 and Arrowhead Tools\n\t// The system is taken from a chemical factory\n\t// This is focusing on the monitoring of products when delivered\n\timport AHFProfileLib::*;\n\timport AHFProfileMetadata::*;\n\timport AHFCoreLib::**;\n\timport ScalarValues::*;\n\n\t#service def APISService {\n\t\tdoc /* Service design */\t\t\n\n\t\tattribute :>> serviceDefinition = \"APISPullService\";\n\t\tattribute :>> intrfce_protocol = \"{JSON}\";\n\t\tattribute :>> serviceURL = \"pull\";\n\t}\n\n\t#servicedd port def APIS_DD :> APISService {\n\t\tdoc /* Service design description with nested protocol-specific ports */\t\n\n\t\t#idd port APIS_HTTP {\n\t\t\t// the asynch implementation of synchronous remote calls\n\t\t\tout cll:CallGiveItems;\n\t\t\tin retrn:ResultGiveItems;\n\t\t}\n\t\t\n\t\t#idd port APIS_MQTT  {\n\t\t\t// GetAllItems functionality\n\t\t\tout pub:Publish;\n\t\t\tout retall:Return_AllItems;\n\t\t\tin subscr:Subscribe;\n\t\t}\n\t}\n\t\n\t// Asynchronous signals\n\tattribute def Publish {nametopic:String;}\n\tattribute def Subscribe{nametopic:String;}\n\tattribute def Return_AllItems {itms:String;}\n\tattribute def Subscribe_giveItems{itms:String;}\n\tattribute def Return_Ack{ack:Boolean;}\n\t\n\t// Signals for implementing the remote procedure call by asynch signals\n\tattribute def CallGiveItems{itms:String; } \n\tattribute def ResultGiveItems{ack:Boolean;}\n\t\n\t#clouddd AHFNorway_LocalCloudDD :> ArrowheadCore {\t\n\t\t#systemdd TellUConsumer {\n\t\t\t#servicedd serviceDiscovery:~ServiceDiscoveryDD ; // communicating with ServiceRegistry\n\t\t\t#servicedd apisp:APIS_DD ;\n\t\t\t\n\t\t\tattribute :>> systemname = \"UngerApisClient\";\n\t\t\tattribute :>> address = \"Unger_network_ip\";\n\t\t\tattribute :>> portno = 0;\n\t\t\t\t\t\t\n\t\t\t// We want an operation call to GiveItems, and actually sending the payload\n\t\t\t// Call apisp::APIS_HTTP::giveItems(in allitems: String = \"All the items\", out ackback:Boolean);\n\t\t\t\n\t\t\tstate TellUbehavior{\n\t\t\t\tentry send CallGiveItems(\"All the items\") via apisp.APIS_HTTP;\n\t\t\t\tthen Wait;\n\t\t\t\tstate Wait;\n\t\t\t\t\taccept rs:ResultGiveItems\n\t\t\t\t\t// Here do whatever about the result rs.ret \n\t\t\t\tthen Wait;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t}\n\t\t\n\t\t#systemdd APISProducer {\n\t\t\t#servicedd serviceDiscovery:~ServiceDiscoveryDD ; // communicating with ServiceRegistry\n\t\t\t#servicedd tellu:~APIS_DD; // providing the APISService\n\t\t\t#servicedd apisc:APIS_DD ; // talking to APISConsumer\n\t\t\t\n\t\t\t:>> systemname = \"PrediktorApisServer\";\n\t\t\t:>> address = \"Prediktor_network_ip\";\n\t\t\t:>> portno = 6565;\n\t\t\tattribute x:Boolean;\n\t\t\t\n\t\t\taction giveItems :> ServiceMethod\n\t\t\t {  in itms:String; out ack:Boolean;\n\t\t\t \t/* Forward itms and return an ack */\n\t\t\t \tfirst start;\n\t\t\t \tthen send Return_AllItems(itms) via apisc.APIS_MQTT;\n\t\t\t \tsuccess = true;\n\t\t\t \tbind ack = success;\n\t\t\t }\n\t\t\t\n\t\t\tstate APISPbehavior{\n\t\t\t\tentry send Publish(\"Return_AllItems\") via apisc.APIS_MQTT;\n\t\t\t\tthen WaitOnData; \n\t\t\t\t\n\t\t\t\tstate WaitOnData;\n\t\t\t\t\taccept cl:CallGiveItems via tellu.APIS_HTTP\n\t\t\t\t\tdo action {\n\t\t\t\t\t\tfirst start;\n\t\t\t\t\t\tthen action giveItems{ in itms=cl.itms; out ack=x; }\n\t\t\t\t\t\tthen send ResultGiveItems(x) via tellu.APIS_HTTP;\n\t\t\t\t\t}\n\t\t\t\tthen WaitOnData;\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t#systemdd APISConsumer {\n\t\t\t#servicedd serviceDiscovery:~ServiceDiscovery ; // communicating with ServiceRegistry\n\t\t\t#servicedd apisp:~APIS_DD ;\n\t\t\t:>> systemname = \"TellUClient\";\n\t\t\t:>> address = \"Prediktor_network_ip\";\n\t\t\t:>> portno = 1;\n\t\t\t\n\t\t\t// Now sending signal to the remote behavior through the port functionality\n\t\t\tstate MQTT_APISP {\n\t\t\t\tentry send Subscribe(\"Return_AllItems\") via apisp.APIS_MQTT; \n\t\t\t\tthen Idle;\t\t\n\t\t\t\tstate Idle;\n\t\t\t\t\taccept Return_AllItems via apisp.APIS_MQTT\n\t\t\t\t\t// Get the stuff and do something with them\n\t\t\t\t\tthen Idle;\n\t\t\t}\n\t\t}\n \t\t\n \t\tpart MQTTServer {\n \t\t\tport getTopic:~APIS_DD;\n \t\t\tport giveTopic:APIS_DD;\n \t\t\t\n \t\t\tstate Serve{\t\t\t\t\n \t\t\t\tentry;\n \t\t\t\tthen Publ;\n \t\t\t\tstate Publ;\n \t\t\t\t\taccept pub:Publish via getTopic.APIS_MQTT\n \t\t\t\t\t// store information about who will provide \"Publish::nametopic\"\n \t\t\t\tthen Subsr;\n \t\t\t\t\n \t\t\t\tstate Subsr;\n \t\t\t\t\taccept Subscribe via giveTopic.APIS_MQTT\n \t\t\t\t\t// store information about who want to receive \"Subscribe::nametopic\"\n \t\t\t\tthen Idle;\n \t\t\t\t\n \t\t\t\tstate Idle;\n \t\t\t\t\taccept retrnall:Return_AllItems via getTopic.APIS_MQTT\n \t\t\t\t\tdo send retrnall via giveTopic.APIS_MQTT\n \t\t\t\tthen Idle;\n \t\t\t} \t\t\t\n \t\t}\n \t\t\t\t\n \t\tconnect APISProducer.apisc to MQTTServer.getTopic; \n \t\tconnect MQTTServer.giveTopic to APISConsumer.apisp; \n\t\t\n \t\tconnect TellUConsumer.apisp to APISProducer.tellu; \n \t\t\n \t\t// Then we need to connect the application systems to the mandatory systems\n \t\tconnect APISProducer.serviceDiscovery to service_registry.serviceDiscovery;\n \t\tconnect TellUConsumer.serviceDiscovery to service_registry.serviceDiscovery;\n \t\tconnect APISConsumer.serviceDiscovery to service_registry.serviceDiscovery;\n \t\t\n \t\t// Same procedure for the other mandatory services\n\t\t\n\t}\n\t\n}",
        "description": "The SysML-V2 code defines a complex system for monitoring product deliveries in a chemical factory using the Arrowhead Framework, involving asynchronous communication between systems through various service definitions, ports, and states, ensuring efficient data exchange and service discovery."
    },
    {
        "code": "package Comments {\n\tdoc /* Documentation Comment */\n\n\tdoc /* Documentation about Package */\n\n\tcomment cmt /* Named Comment */\t\n\tcomment cmt_cmt about cmt /* Comment about Comment */\n\t\n\tcomment about C /* Documention Comment on Part Def */\n\tpart def C {\n\t\tdoc /* Documentation in Part Def */\n\t\tcomment /* Comment in Part Def */\n\t\tcomment about Comments /* Comment about Package */\n\t}\n}",
        "description": "The SysML-V2 code package \"Comments\" demonstrates the use of documentation and named comments within a package, including comments about comments and documentation within part definitions, showcasing the hierarchical and descriptive capabilities of SysML-V2 for model documentation."
    },
    {
        "code": "package VehicleDefinitions {\n\tdoc\n\t/*\n\t * Example vehicle definitions model.\n\t */\n\n\timport ScalarValues::*;\n\timport Quantities::*;\n\timport MeasurementReferences::*;\n\timport ISQ::*;\n\timport SI::*;\n\t\n\t/* PART DEFINITIONS */\n\t\n\tpart def Vehicle;\t\n\tpart def Transmission;\t\n\tpart def AxleAssembly;\n\tpart def Axle {\n\t\tport leftMountingPoint: AxleMountIF;\n\t\tport rightMountingPoint: AxleMountIF;\n\t}\n\tpart def Wheel {\n\t\tport hub: WheelHubIF;\n\t}\n\tpart def Lugbolt {\n\t\tattribute tighteningTorque :> ISQ::torque;\n\t}\n\t\n\t/* PORT DEFINITIONS */\n\t\n\tport def DriveIF { \n\t\tin driveTorque :> ISQ::torque;\n\t}\n\t\n\tport def AxleMountIF { \n\t\tout transferredTorque :> ISQ::torque;\n\t}\n\t\n\tport def WheelHubIF { \n\t\tin appliedTorque :> ISQ::torque;\n\t}\n\t\n\t/* INTERFACE DEFINITIONS */\n\t\n\tinterface def Mounting {\n\t\tdoc /* The definition of the interface for mounting a Wheel to an Axle. */\n\t\tend axleMount: AxleMountIF;\n\t\tend hub: WheelHubIF;\n\t\t\n\t\tflow axleMount.transferredTorque to hub.appliedTorque;\n\t}\n}",
        "description": "The SysML-V2 code defines a vehicle system model with part, port, and interface definitions for components like Vehicle, Transmission, AxleAssembly, Axle, Wheel, and Lugbolt, specifying their attributes and interactions through torque-related ports and interfaces."
    },
    {
        "code": "package VehicleIndividuals {\n\timport VehicleUsages::*;\n\timport Time::DateTime;\n\t\n\tpackage IndividualDefinitions {\n\n\t\tindividual part def Vehicle1 :> Vehicle {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * This is an individual Vehicle with a mass of 1800 kg.\n\t\t\t */\n\t\t\t\n\t\t\tattribute redefines mass = 1800 [kg];\n\t\t}\n\t\t\n\t\tindividual part def Vehicle2 :> Vehicle {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * This is an individual Vehicle with a mass of 1700 kg.\n\t\t\t */\n\t\t\n\t\t\tattribute redefines mass = 1700 [kg];\n\t\t}\n\t\t\n\t\tindividual part def AxleAssembly1 :> AxleAssembly;\n\t\t\n\t\tindividual part def Wheel1 :> Wheel;\n\t\tindividual part def Wheel2 :> Wheel;\n\t}\n\t\n\tpackage IndividualSnapshots {\n\t\timport IndividualDefinitions::*;\n\t\n\t\tattribute t0: DateTime;\n\t\tattribute t1: DateTime;\n\t\t\n\t\tsnapshot part vehicle1_t0: Vehicle1 {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * This is a snapshot of Vehicle1 at time t0;\n\t\t\t */\n\t\t\n\t\t\t// Note: Timestamping of snapshots is not yet formalized.\n\t\t\tattribute t = t0;\n\t\t}\n\t\t\n\t\ttimeslice part vehicle1_t0_t1: Vehicle1 {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * This is a time slice of Vehicle1 starting at snapshot vehicle1_t0 \n\t\t\t * (time t0) and ending at time t1.\n\t\t\t */\n\t\t\n\t\t\tsnapshot :>> start = vehicle1_t0;\n\t\t\tsnapshot :>> done {\n\t\t\t\tattribute t = t1;\n\t\t\t}\n\t\t}\t\n\t}\n\t\n\tpackage IndividualConfigurations {\n\t\timport IndividualSnapshots::*;\n\t\n\t\tindividual part vehicle1_C2: Vehicle1 :> vehicle_C2 {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * This asserts that for some portion of its lifetime, Vehicle1 conforms\n\t\t\t * to the configuration vehicle_C2;\n\t\t\t */\n\t\t}\t\n\t\t\t\n\t\tsnapshot part vehicle1_C2_t0 : Vehicle1 :> vehicle1_C2, vehicle1_t0 {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * This is a snapshot of Vehicle1 in configuration vehicle1_C2 at time t0.\n\t\t\t */\n\t\t\n\t\t\tsnapshot axleAssembly1_t0: AxleAssembly1 :>> frontAxleAssembly {\n\t\t\t\tdoc\n\t\t\t\t/*\n\t\t\t\t * frontAxleAssembly is a feature of vehicle1_C2.\n\t\t\t\t */\n\t\t\t\n\t\t\t\tsnapshot leftFrontWheel_t0: Wheel1 :>> leftFrontWheel {\n\t\t\t\t\tdoc\n\t\t\t\t\t/*\n\t\t\t\t\t * This asserts that Wheel1 is the leftFrontWheel of vehicle_C2_t0\n\t\t\t\t\t * (leftFrontWheel is a feature of vehicle_C2::frontAxleAssembly).\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tsnapshot part vehicle1_C2_t1 : Vehicle1 :> vehicle1_C2, vehicle1_t0_t1.done {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * This is a snapshot of Vehicle1 in configuration vehicle_C2 at time t1.\n\t\t\t */\n\t\t\n\t\t\tsnapshot axleAssembly1_t1: AxleAssembly1 :>> frontAxleAssembly {\n\t\t\t\tsnapshot rightFrontWheel_t1: Wheel1 :>> rightFrontWheel {\n\t\t\t\t\tdoc\n\t\t\t\t\t/*\n\t\t\t\t\t * This asserts that Wheel1 is the rightFrontWheel of vehicle_C2_t1.\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n}",
        "description": "The SysML-V2 code defines individual vehicles with specific attributes, captures their states at different times through snapshots and timeslices, and specifies configurations where these vehicles conform to certain features, associating specific parts like axles and wheels with each configuration."
    },
    {
        "code": "package VehicleUsages {\n\tdoc\n\t/*\n\t * Example usages of elements from the vehicle definitions model.\n\t */\n\n\timport SI::N;\n\timport SI::m;\n\timport VehicleDefinitions::*;\n\timport ScalarFunctions::*;\n\n\t/* VALUES */\t \n\tT1 = 10.0 [N * m];\n\tT2 = 20.0 [N * m];\n\t\n\t/* PARTS */\t\n\tpart narrowRimWheel: Wheel {\n\t\tdoc /* Narrow-rim wheel configuration with 4 to 5 lugbolts. */\n\n\t\tpart lugbolt: Lugbolt[4..5];\n\t}\n\t\n\tpart wideRimWheel: Wheel {\n\t\tdoc /* Wide-rim wheel configuration with 4 to 6 lugbolts. */\t\n\n\t\tpart lugbolt: Lugbolt[4..6];\n\t}\n\n\tpart vehicle_C1: Vehicle {\n\t\tdoc /* Basic Vehicle configuration showing a part hierarchy. */\n\n\t\tpart frontAxleAssembly: AxleAssembly {\n\t\t\tpart frontWheel[2] subsets narrowRimWheel {\n\t\t\t\tpart redefines lugbolt[4] {\n\t\t\t\t\tattribute redefines tighteningTorque = T1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart frontAxle: Axle;\n\t\t}\t\t\n\t\tpart rearAxleAssembly: AxleAssembly {\n\t\t\tpart rearWheel[2] subsets wideRimWheel {\n\t\t\t\tpart redefines lugbolt[6] {\n\t\t\t\t\tattribute redefines tighteningTorque = T2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpart rearAxle: Axle;\t\t\t\n\t\t}\n\t}\n\t\n\tpart vehicle_C2 subsets vehicle_C1 {\n\t\tdoc /* Specialized configuration with part-specific ports. */\n\n\t\tpart redefines frontAxleAssembly {\n\t\t\tpart leftFrontWheel subsets frontWheel = frontWheel#(1);\n\t\t\tpart rightFrontWheel subsets frontWheel = frontWheel#(2);\n\t\t\t\n\t\t\tinterface leftFrontMount: Mounting connect \n\t\t\t\tfrontAxle.leftMountingPoint to leftFrontWheel.hub;\n\t\t\t\t\n\t\t\tinterface rightFrontMount: Mounting connect \n\t\t\t\tfrontAxle.rightMountingPoint to rightFrontWheel.hub;\n\t\t}\n\t\t\n\t\tpart rearAxleAssembly redefines vehicle_C1::rearAxleAssembly {\n\t\t\tpart leftRearWheel subsets rearWheel = rearWheel#(1);\n\t\t\tpart rightRearWheel subsets rearWheel = rearWheel#(2);\n\n\t\t\tinterface leftRearMount: Mounting connect \n\t\t\t\trearAxle.leftMountingPoint to leftRearWheel.hub;\n\t\t\t\t\n\t\t\tinterface rightRearMount: Mounting connect \n\t\t\t\trearAxle.rightMountingPoint to rightRearWheel.hub;\n\t\t}\t\t\n\t}\n\t\n\tpart vehicle_C3 subsets vehicle_C2 {\n\t\tdoc /* Further specialized configuration with a connection to a deeply-nested port. */\n\n\t\t\n\t\tpart transmission: Transmission {\n\t\t\tport drive: ~DriveIF;\n\t\t}\n\t\t\n\t\tpart redefines rearAxleAssembly {\n\t\t\tpart redefines rearAxle {\n\t\t\t\tport drive: DriveIF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tinterface driveShaft connect \n\t\t\ttransDrive ::> transmission.drive to axleDrive ::> rearAxleAssembly.rearAxle.drive {\n\t\t\tflow transDrive.driveTorque to axleDrive.driveTorque;\n\t\t}\t\t\n\t}\n}",
        "description": "The SysML-V2 code defines various vehicle configurations with specific part hierarchies, attributes, and connections, demonstrating the usage of imported elements and specialized configurations through part redefinitions and interface connections."
    },
    {
        "code": "package SimpleVehicleModel{\n    // 2023-02 release\n    import Definitions::*;  \n    import ISQ::*;\n    package Definitions{\n        import PartDefinitions::*;\n        import PortDefinitions::*;\n        import ItemDefinitions::*;\n        import SignalDefinitions::*;\n        import InterfaceDefinitions::*;\n        import AllocationDefinitions::*;\n        import ActionDefinitions::*;\n        import StateDefinitions::*;\n        import RequirementDefinitions::*;\n        import AttributeDefinitions::*;\n        import IndividualDefinitions::*;\n        import MetadataDefinitions::**;\n        import KeyWord_MetadataDefinitions::*;\n        package PartDefinitions{\n            part def Vehicle {\n                attribute mass :> ISQ::mass;\n                attribute dryMass:>ISQ::mass;\n                attribute cargoMass:>ISQ::mass;\n                attribute position:>ISQ::length;\n                attribute velocity:>ISQ::speed;\n                attribute acceleration:>ISQ::acceleration;\n                attribute electricalPower:>ISQ::power;\n                attribute Tmax:>ISQ::temperature;\n                attribute maintenanceTime: Time::DateTime; \n                attribute brakePedalDepressed: Boolean;\n                port ignitionCmdPort:IgnitionCmdPort;\n                port pwrCmdPort:PwrCmdPort;\n                port vehicleToRoadPort:VehicleToRoadPort;\n                port statusPort:StatusPort;\n                perform action providePower;\n                perform action provideBraking;\n                perform action controlDirection;\n                perform action performSelfTest;\n                perform action applyParkingBrake;\n                perform action senseTemperature;\n                exhibit state vehicleStates parallel {\n                    ref controller : VehicleController;\n                    state operatingStates {\n                        entry action initial;\n                        state off;                    \n                        state starting;                    \n                        state on {\n                            entry performSelfTest;\n                            do providePower;\n                            exit applyParkingBrake;\n                            constraint {electricalPower<=500[W]}\n                        }\n\n                        transition initial then off;\n\n                        transition off_To_starting\n                            first off\n                            accept ignitionCmd:IgnitionCmd via ignitionCmdPort\n                                if ignitionCmd.ignitionOnOff==IgnitionOnOff::on and brakePedalDepressed\n                            do send StartSignal() to controller\n                            then starting;\n                        \n                        transition starting_To_on\n                            first starting\n                            accept VehicleOnSignal\n                            then on;\n                        \n                        transition on_To_off\n                            first on\n                            accept VehicleOffSignal\n                            do send OffSignal() to controller\n                            then off;\n                    }\n\n                    state healthStates {\n                        entry action initial;\n                        do senseTemperature{\n                            out temp;\n                        }\n\n                        state normal;\n                        state maintenance;\n                        state degraded;                    \n\n                        transition initial then normal;\n\n                        transition normal_To_maintenance\n                            first normal\n                            accept at maintenanceTime\n                            then maintenance;\n\n                        transition normal_To_degraded\n                            first normal\n                            accept when senseTemperature.temp > Tmax \n                            do send OverTemp() to controller\n                            then degraded;\n\n                        transition maintenance_To_normal\n                            first maintenance\n                            accept ReturnToNormal\n                            then normal;\n\n                        transition degraded_To_normal\n                            first degraded\n                            accept ReturnToNormal\n                            then normal;\n                    }\n                }\n            }\n            part def Engine{\n                attribute mass :> ISQ::mass;\n                attribute peakHorsePower:>ISQ::power;\n                attribute fuelEfficiency:Real;\n                attribute cost:Real;\n                attribute displacement :> ISQ::volume;\n                port engineControlPort: ~ControlPort;\n                port fuelInPort: ~ FuelPort;\n                port fuelCmdPort:FuelCmdPort;\n                port drivePwrPort:DrivePwrPort;\n                port ignitionCmdPort:IgnitionCmdPort;\n                port flyWheelPort;\n                perform action generateTorque;\n                exhibit state engineStates{\n                    state off;\n                    state starting;\n                    state on{\n                        do generateTorque;\n                    }\n                }\n            }\n            part def StarterMotor{\n                port gearPort:GearPort;\n            }\n            part def Cylinder;\n            part def Transmission{\n                attribute gearRatio:Real;\n                port clutchPort:~DrivePwrPort;\n                exhibit state transmissionStates;\n            }\n            part def Driveshaft;\n            part def AxleAssembly;\n            part def Axle{\n                attribute mass:>ISQ::mass;\n            }\n            part def FrontAxle:>Axle{\n                attribute steeringAngle:>ISQ::angularMeasure;\n            }\n            part def HalfAxle{\n                port shankCompositePort:ShankCompositePort{\n                }\n            }\n            part def Differential;\n            part def Wheel{\n                attribute diameter:LengthValue;\n                port lugNutCompositePort:LugNutCompositePort;\n            }\n            part def Hub{\n                port shankCompositePort:ShankCompositePort;\n            }\n            abstract part def Software;\n            part def VehicleSoftware:>Software;\n            part def VehicleController:>Software {\n                port controlPort:ControlPort;\n                exhibit state controllerStates parallel {\n                    state operatingStates {\n                        entry action initial; \n                        state off;\n                        state on;    \n                        transition initial then off;\n                        transition 'off-on'\n                            first off\n                            accept StartSignal\n                            then on;\n                        transition 'on-off'\n                            first on\n                            accept OffSignal\n                            then off;\n                    }\n                }  \n            }\n            part def CruiseController:>Software {\n                port setSpeedPort:~SetSpeedPort;\n                port speedSensorPort:~SpeedSensorPort;\n                port cruiseControlPort:CruiseControlPort;\n                exhibit state cruiseControllerStates;\n            }\n            part def SpeedSensor{\n                port speedSensorPort:SpeedSensorPort;\n            }\n            part def FuelTank{\n                attribute mass :> ISQ::mass;\n                ref item fuel:Fuel{\n                    attribute :>> fuelMass;\n                }\n                attribute fuelKind:FuelKind;\n                attribute fuelMassMax:>ISQ::mass;\n                assert constraint fuelConstraint {fuel.fuelMass<=fuelMassMax}\n                port fuelOutPort:FuelPort;\n                port fuelInPort:~FuelPort;\n            }\n            part def BodyAssy;\n            part def Body{\n                attribute color:Colors;\n            }\n            part def Thermostat;\n            part def WaterHose;\n            part def Road{\n                attribute incline:Real;\n                attribute friction:Real;\n            }\n            part def Engine4Cyl;\n            part def Engine6Cyl;\n            part def TransmissionChoices;\n            part def TransmissionAutomatic;\n            part def TransmissionManual;\n            part def Sunroof;\n            \n            //logical Components\n            part def ElectricalGenerator;\n            part def TorqueGenerator;\n            part def SteeringSubsystem;\n            part def BrakingSubsystem;\n        }\n        package PortDefinitions{\n            port def IgnitionCmdPort{\n                in item ignitionCmd:IgnitionCmd;\n            }\n            port def StatusPort;\n            port def GearPort;\n            port def PwrCmdPort{\n                in item pwrCmd:PwrCmd;\n            }\n            port def FuelCmdPort:>PwrCmdPort{\n                in item fuelCmd:FuelCmd redefines pwrCmd;\n            }\n            port def FuelPort{\n                out item fuel:Fuel;\n            }\n            port def DrivePwrPort{\n                out torque:Torque;\n            }\n            port def ShaftPort_a;\n            port def ShaftPort_b;\n            port def ShaftPort_c;\n            port def ShaftPort_d;\n            port def DiffPort;\n            port def AxlePort;\n            port def AxleToWheelPort;\n            port def WheelToAxlePort;\n            port def WheelToRoadPort;\n\n            port def LugNutCompositePort{\n                port lugNutPort:LugNutPort [*];\n            }\n            port def ShankCompositePort{\n                port shankPort:ShankPort [*];\n            }\n            port def LugNutPort{\n                attribute threadDia;\n                attribute threadPitch;\n            }\n            port def ShankPort{\n                attribute threadDia;\n                attribute threadPitch;   \n                attribute shaftLength;\n            }\n            \n            port def VehicleToRoadPort;\n            port def ControlPort;\n            port def CruiseControlPort:>ControlPort;\n            port def SpeedSensorPort;\n            port def SetSpeedPort;\n\n            port def DriverCmdPort{\n                out item driverCmd[*]:DriverCmd;\n            }\n            port def HandPort :> DriverCmdPort {\n                out item ignitionCmd:IgnitionCmd subsets driverCmd;\n                out item pwrCmd:PwrCmd subsets driverCmd;\n            }  \n        }\n        package ItemDefinitions{\n            item def PwrCmd{\n                attribute throttleLevel:Real;\n            }\n            item def FuelCmd:>PwrCmd;\n            item def Fuel{\n                attribute fuelMass:>ISQ::mass;\n            }\n            item def SensedSpeed{\n                attribute speed:>ISQ::speed;\n            }\n        }\n        package SignalDefinitions{\n            item def Cmd{\n            }\n            item def DriverCmd;\n            item def IgnitionCmd:>DriverCmd{\n                attribute ignitionOnOff:IgnitionOnOff;\n            }\n            item def EngineStatus;\n            \n            attribute def VehicleStartSignal;\n            attribute def VehicleOnSignal;\n            attribute def VehicleOffSignal;\n            attribute def StartSignal;\n            attribute def OffSignal;\n            attribute def OverTemp;\n            attribute def ReturnToNormal;\n            attribute def SetSpeed:>Real;\n        }\n        package InterfaceDefinitions{\n            interface def EngineToTransmissionInterface{\n                end p1:DrivePwrPort;\n                end p2:~DrivePwrPort;\n                flow p1.torque to p2.torque;\n            }\n            interface def FuelInterface {\n                end fuelOutPort:FuelPort;\n                end fuelInPort:~FuelPort;\n                flow of Fuel from fuelOutPort.fuel to fuelInPort.fuel;\n            }\n            \n            interface def WheelFastenerInterface{\n                end lugNutPort:LugNutPort;\n                end shankPort:ShankPort;\n                attribute maxTorque : Torque;\n                constraint {lugNutPort.threadDia == shankPort.threadDia}\n            }\n            interface def WheelHubInterface{\n                end lugNutCompositePort:LugNutCompositePort;\n                end shankCompositePort:ShankCompositePort;\n                interface wheelFastenerInterface:WheelFastenerInterface [5]\n                    connect lugNutCompositePort.lugNutPort to shankCompositePort.shankPort;\n            }\n        }\n        package AllocationDefinitions{\n            allocation def LogicalToPhysical{\n                end #logical logicalEnd;\n                end #physical physicalEnd;\n            }\n        }\n        package ActionDefinitions{\n            action def ProvidePower {\n                in item pwrCmd:PwrCmd;\n                out wheelToRoadTorque:Torque[2];\n            }\n            action def GenerateTorque {\n                in item fuelCmd:FuelCmd;\n                out engineTorque:Torque;\n            }\n            action def AmplifyTorque {\n                in engineTorque:Torque;\n                out transmissionTorque:Torque;\n            }\n            action def TransferTorque {\n                in transmissionTorque:Torque;\n                out driveshaftTorque:Torque;\n            }\n            action def DistributeTorque {\n                in driveshaftTorque:Torque;\n                out wheelToRoadTorque:Torque[2];\n            }\n            action def PerformSelfTest;\n            action def ApplyParkingBrake;\n            action def SenseTemperature{\n                out temp: ISQ::TemperatureValue;\n            }\n        }    \n        package StateDefinitions {\n            state def VehicleStates;\n            state def ControllerStates;  \n            state def CruiseControllerStates;\n        }\n        package RequirementDefinitions{\n            requirement def MassRequirement{\n                doc /*The actual mass shall be less than the required mass*/\n                attribute massRequired:>ISQ::mass;\n                attribute massActual:>ISQ::mass;\n                require constraint {massActual<=massRequired}\n            }\n            requirement def ReliabilityRequirement{\n                doc /*The actual reliability shall be greater than the required reliability*/\n                attribute reliabilityRequired:Real;\n                attribute reliabilityActual:Real;\n                require constraint {reliabilityActual>=reliabilityRequired}\n            }\n            requirement def TorqueGenerationRequirement {\n                doc /* The engine shall generate torque as a function of RPM as shown in Table 1. */\n                subject generateTorque:ActionDefinitions::GenerateTorque;\n            }\n            requirement def DrivePowerOutputRequirement { \n                doc /* The engine shall provide a connection point to transfer torque to the transmission.*/\n            }\n            requirement def FuelEconomyRequirement {\n                doc /* The vehicle shall maintain an average fuel economomy of at least x miles per gallon for the nominal \n                driving scenario */\n                attribute actualFuelEconomy :> distancePerVolume;\n                attribute requiredFuelEconomy :> distancePerVolume;\n                require constraint {actualFuelEconomy >= requiredFuelEconomy}\n            }\n        }\n        package AttributeDefinitions{\n            import ScalarValues::*;\n            import Quantities::*;\n            import MeasurementReferences::DerivedUnit;\n            import SIPrefixes::kilo;\n            // Numerical Functions provides basic operators such as Sum expression\n            import NumericalFunctions::*;\n            import SI::*;\n            import USCustomaryUnits::*;\n            alias Torque for ISQ::TorqueValue;\n            \n            enum def Colors {black;grey;red;}\n            enum def DiameterChoices:>ISQ::LengthValue{\n                enum = 60 [mm];\n                enum = 80 [mm];\n                enum = 100 [mm];\n            }\n            attribute cylinderDiameter: DiameterChoices = 80 [mm]; \n            enum def IgnitionOnOff {on;off;}\n            enum def FuelKind {gas;diesel;}\n\n            distancePerVolume :> scalarQuantities = distance / volume;\n            timePerDistance :> scalarQuantities = time / distance;\n            volumePerDistance :> scalarQuantities = volume / distance;\n            volumePerTime :> scalarQuantities = volume / time;\n            \n            // kpl is approx .425 * mpg\n            kpl : DerivedUnit = km / L;\n            rpm : DerivedUnit = 1 / SI::min;\n            kW : DerivedUnit = kilo * W;\n            \n        }\n        package IndividualDefinitions{\n            individual def VehicleRoadContext_1:>GenericContext::Context;\n            individual def Vehicle_1:>Vehicle;\n            individual def FrontAxleAssembly_1:>AxleAssembly;\n            individual def FrontAxle_1:>FrontAxle;\n            individual def Wheel_1:>Wheel;\n            individual def Wheel_2:>Wheel;\n            individual def RearAxleAssembly_1:>AxleAssembly;\n            individual def Road_1:>Road;\n        }\n        package MetadataDefinitions { \n            import AnalysisTooling::*;   \n            metadata def Safety {\n                attribute isMandatory : Boolean;\n            }\n            metadata def Security;\n        }\n        package KeyWord_MetadataDefinitions{\n            import Metaobjects::SemanticMetadata;\n            \n            // the following is used to define the key word failureMode\n            state failureModes[*] nonunique;\n            \n            // with alias <fm>\n            metadata def <fm> failureMode :> SemanticMetadata {\n                :>> baseType = failureModes meta SysML::StateUsage;\n            }\n            \n            occurrence logicalOccurrences [*] nonunique;\n            \n            metadata def <l> logical :> SemanticMetadata {\n                :>> baseType = logicalOccurrences meta SysML::Usage;\n            }\n            \n            occurrence physicalOccurrences [*] nonunique;\n            \n            metadata def <p> physical :> SemanticMetadata {\n                :>> baseType = physicalOccurrences meta SysML::Usage;\n            }  \n        }\n        package GenericContext {\n\n            part def Context {\n                attribute time:TimeValue;\n                attribute spatialCF: CartesianSpatial3dCoordinateFrame[1] { :>> mRefs = (m, m, m); }\n                attribute velocityCF: CartesianVelocity3dCoordinateFrame[1] = spatialCF/s;\n                attribute accelarationCF: CartesianAcceleration3dCoordinateFrame[1] = velocityCF/s;\n            }\n        }\n    }\n\n    package VehicleLogicalConfiguration{\n        package PartsTree{\n            #logical part vehicleLogical:Vehicle{\n                part torqueGenerator:TorqueGenerator{\n                    action generateTorque;\n                }\n                part electricalGenerator:ElectricalGenerator{\n                    action generateElectricity;\n                }\n                part steeringSystem:SteeringSubsystem;\n                part brakingSubsystem:BrakingSubsystem;\n            }\n        }\n    }\n    package VehicleLogicalToPhysicalAllocation{\n        import VehicleConfigurations::VehicleConfiguration_b::PartsTree::**;\n        import VehicleLogicalConfiguration::PartsTree::*;\n\n        allocation vehicleLogicalToPhysicalAllocation:LogicalToPhysical\n            allocate vehicleLogical to vehicle_b{\n                allocate vehicleLogical.torqueGenerator to vehicle_b.engine{\n                    allocate vehicleLogical.torqueGenerator.generateTorque to vehicle_b.engine.generateTorque;\n                }\n                allocate vehicleLogical.electricalGenerator to vehicle_b.engine{\n                    allocate vehicleLogical.electricalGenerator.generateElectricity to vehicle_b.engine.alternator.generateElectricity;\n                }\n            }\n    } \n    package VehicleConfigurations{\n        package VehicleConfiguration_a{\n            package PartsTree{\n                part vehicle_a:Vehicle{\n                    attribute mass redefines Vehicle::mass=dryMass+cargoMass+fuelTank.fuel.fuelMass;\n                    attribute dryMass redefines Vehicle::dryMass=sum(partMasses);\n                    attribute redefines Vehicle::cargoMass=0 [kg];\n                    attribute partMasses [*] nonunique :>ISQ::mass;\n                    part fuelTank:FuelTank{\n                        attribute redefines mass=75[kg];\n                        ref item redefines fuel{\n                            attribute redefines fuelMass=50[kg];\n                        }   \n                    }\n                    part frontAxleAssembly:AxleAssembly{\n                        attribute mass :> ISQ::mass=800[kg];\n                        part frontAxle:Axle;\n                        part frontWheels:Wheel[2];\n                    }\n                    part rearAxleAssembly:AxleAssembly{\n                        attribute mass :> ISQ::mass=875[kg];\n                        attribute driveTrainEfficiency:Real = 0.6;\n                        part rearAxle:Axle;\n                        part rearWheels:Wheel[2]{\n                            attribute redefines diameter;\n                        }\n                    }\n                }\n            }\n            package ActionTree{  \n            }\n            package Requirements{\n            }\n        }\n        package VehicleConfiguration_b{\n            //Shapes library for simple geometry\n            import ShapeItems::Box;\n            import ParametersOfInterestMetadata::mop;\n            import ModelingMetadata::*; // incudes status info\n            \n            package PartsTree{\n                part vehicle_b : Vehicle{\n                    #mop attribute mass redefines mass=dryMass+cargoMass+fuelTank.fuel.fuelMass;\n                    attribute dryMass redefines dryMass=sum(partMasses);\n                    attribute redefines cargoMass default 0 [kg];\n                    attribute partMasses=(fuelTank.mass,frontAxleAssembly.mass,rearAxleAssembly.mass,engine.mass,transmission.mass,driveshaft.mass);\n                    attribute avgFuelEconomy :> distancePerVolume;\n                    port fuelCmdPort: FuelCmdPort redefines pwrCmdPort {\n                        in item fuelCmd redefines pwrCmd;\n                    }\n                    port setSpeedPort:~SetSpeedPort;\n                    port vehicleToRoadPort redefines vehicleToRoadPort{\n                        port wheelToRoadPort1:WheelToRoadPort;\n                        port wheelToRoadPort2:WheelToRoadPort;\n                    }\n                    perform ActionTree::providePower redefines providePower;\n                    perform ActionTree::performSelfTest redefines performSelfTest;\n                    perform ActionTree::applyParkingBrake redefines applyParkingBrake;\n                    perform ActionTree::senseTemperature redefines senseTemperature;\n                    exhibit state vehicleStates redefines vehicleStates;\n                    \n                    // Example vehicle with simple enveloping shape that is a solid \n                    item :> envelopingShapes : Box[1] {\n                        length1:>> length = 4800 [mm];\n                        width1:>> width = 1840 [mm];\n                        height1:>> height = 1350 [mm];\n                    }\n                    \n                    part fuelTank:FuelTank{\n                        attribute redefines mass=75[kg];\n                        ref item redefines fuel{\n                            attribute redefines fuelMass=60[kg];\n                        }\n                        attribute redefines fuelMassMax=60 [kg];\n                    }\n                    part frontAxleAssembly:AxleAssembly{\n                        attribute mass :> ISQ::mass=800[kg];\n                        port shaftPort_d:ShaftPort_d;\n                        part frontAxle:FrontAxle;\n                        part frontWheels:Wheel[2];\n                    }\n                    \n                    part rearAxleAssembly:AxleAssembly{\n                        attribute mass :> ISQ::mass=875[kg];\n                        attribute driveTrainEfficiency:Real = 0.6;\n                        port shaftPort_d:ShaftPort_d;\n                        perform providePower.distributeTorque;\n                        part rearWheel1:Wheel{\n                            attribute redefines diameter;\n                            port wheelToRoadPort:WheelToRoadPort;\n                            port lugNutCompositePort :>> lugNutCompositePort{\n                                port lugNutPort :>> lugNutPort [5];\n                            }\n                        }\n                        part rearWheel2:Wheel{\n                            attribute redefines diameter;\n                            port wheelToRoadPort:WheelToRoadPort;\n                            port lugNutCompositePort :>> lugNutCompositePort{\n                                port lugNutPort :>> lugNutPort [5];\n                            }\n                        }\n                        part differential:Differential{\n                            port shaftPort_d:ShaftPort_d;\n                            port leftDiffPort:DiffPort;\n                            port rightDiffPort:DiffPort;\n                        }\n                        part rearAxle{\n                            part leftHalfAxle:HalfAxle{\n                                port leftAxleToDiffPort:AxlePort;\n                                port shankCompositePort :>> shankCompositePort{\n                                    port shankPort :>> shankPort [5];\n                                }\n                            }\n                            part rightHalfAxle:HalfAxle{\n                                port rightAxleToDiffPort:AxlePort;\n                                port shankCompositePort :>> shankCompositePort {\n                                    port shankPort :>> shankPort [5];\n                                }\n                            }\n                        }\n                        \n                        bind shaftPort_d=differential.shaftPort_d;\n                        connect differential.leftDiffPort to rearAxle.leftHalfAxle.leftAxleToDiffPort;\n                        connect differential.rightDiffPort to rearAxle.rightHalfAxle.rightAxleToDiffPort;\n                        \n                        interface wheelToleftHalAxleInterface:WheelHubInterface \n                            connect rearWheel1.lugNutCompositePort [1] to rearAxle.leftHalfAxle.shankCompositePort [1];\n                        interface wheelTorightHalAxleInterface:WheelHubInterface\n                            connect rearWheel2.lugNutCompositePort [1] to rearAxle.rightHalfAxle.shankCompositePort [1];\n                        \n                    }\n                    part starterMotor:StarterMotor;\n                    part engine:Engine{\n                        perform providePower.generateTorque redefines generateTorque;            \n                        part cylinders:Cylinder[4..6];\n                        part alternator{\n                            action generateElectricity;\n                        }\n                        satisfy Requirements::engineSpecification by vehicle_b.engine{\n                            requirement torqueGenerationRequirement :>> torqueGenerationRequirement{\n                                subject generateTorque redefines generateTorque = vehicle_b.engine.generateTorque;\n                            }\n                            requirement drivePowerOuputRequirement :>> drivePowerOutputRequirement{\n                                port torqueOutPort redefines torqueOutPort=vehicle_b.engine.drivePwrPort;\n                            }\n                        } \n                    }\n                    part transmission:Transmission{\n                        attribute mass :> ISQ::mass=100[kg];\n                        port shaftPort_a:ShaftPort_a;\n                        perform providePower.amplifyTorque;\n                    }\n                    part driveshaft:Driveshaft{\n                        attribute mass :> ISQ::mass=100[kg];\n                        port shaftPort_b:ShaftPort_b;\n                        port shaftPort_c:ShaftPort_c;\n                        perform providePower.transferTorque;\n                    }\n                    part vehicleSoftware:VehicleSoftware{\n                        part vehicleController: VehicleController {\n                            exhibit state controllerStates redefines controllerStates;\n                            part cruiseController:CruiseController;\n                        }\n                    }\n                    part speedSensor:SpeedSensor;\n                    \n                    // parts in bodyAssy and interioer are marked as safety or security features\n                    part bodyAssy:BodyAssy{\n                        part body:Body{\n                            attribute :>> color = Colors::red;  \n                        }\n                        part bumper {@Safety{isMandatory = true;}}\n                        part keylessEntry {@Security;}\n                    }\n                    part interior {\n                        part alarm {@Security;}\n                        part seatBelt[2] {@Safety{isMandatory = true;}}\n                        part frontSeat[2];\n                        part driverAirBag {@Safety{isMandatory = false;}}\n                    }\n                    \n                    //connections\n                    bind engine.fuelCmdPort=fuelCmdPort;\n\n                    interface engineToTransmissionInterface:EngineToTransmissionInterface\n                        connect engine.drivePwrPort to transmission.clutchPort;\n                \n                    interface fuelInterface:FuelInterface\n                        connect fuelTank.fuelOutPort to engine.fuelInPort;\n\n                    allocate ActionTree::providePower.generateToAmplify to engineToTransmissionInterface;\n                    \n                    bind engine.ignitionCmdPort=ignitionCmdPort;\n                    connect starterMotor.gearPort to engine.flyWheelPort;\n                    connect vehicleSoftware.vehicleController.controlPort to engine.engineControlPort;\n                    bind vehicle_b.setSpeedPort = vehicleSoftware.vehicleController.cruiseController.setSpeedPort;\n                    connect speedSensor.speedSensorPort to vehicleSoftware.vehicleController.cruiseController.speedSensorPort;\n                    bind vehicleSoftware.vehicleController.cruiseController.cruiseControlPort = vehicleSoftware.vehicleController.controlPort;\n                    connect transmission.shaftPort_a to driveshaft.shaftPort_b; \n                    connect driveshaft.shaftPort_c to rearAxleAssembly.shaftPort_d;\n                    bind rearAxleAssembly.rearWheel1.wheelToRoadPort=vehicleToRoadPort.wheelToRoadPort1;\n                    bind rearAxleAssembly.rearWheel2.wheelToRoadPort=vehicleToRoadPort.wheelToRoadPort2;\n                    \n                    satisfy Requirements::vehicleSpecification by vehicle_b{\n                        requirement vehicleMassRequirement:>>vehicleMassRequirement{\n                            attribute redefines massActual=vehicle_b.mass;\n                            attribute redefines fuelMassActual = vehicle_b.fuelTank.fuel.fuelMass;\n                        }\n                    }\n                }\n            }\n            package ActionTree{\n                action providePower:ProvidePower{\n                    in item fuelCmd:FuelCmd redefines pwrCmd;\n                    out wheelToRoadTorque redefines wheelToRoadTorque [2] = distributeTorque.wheelToRoadTorque;\n                    action generateTorque:GenerateTorque {\n                        in item = providePower.fuelCmd;\n                    }\n                    action amplifyTorque:AmplifyTorque;\n                    action transferTorque:TransferTorque;\n                    action distributeTorque:DistributeTorque;\n                    \n                    //named flow\n                    flow generateToAmplify from generateTorque.engineTorque to amplifyTorque.engineTorque;\n                    //unnamed flows\n                    flow amplifyTorque.transmissionTorque to transferTorque.transmissionTorque;\n                    flow transferTorque.driveshaftTorque to distributeTorque.driveshaftTorque;\n                }\n                action performSelfTest: PerformSelfTest;\n                action applyParkingBrake: ApplyParkingBrake;\n                action senseTemperature: SenseTemperature;\n            }                   \n            package DiscreteInteractions{\n                package Sequence{\n                    part def Driver{\n                        port p1;\n                        port p2;\n                    }\n\n                    part part0{\n                        perform action startVehicle{\n                            action turnVehicleOn send ignitionCmd via driver.p1{\n                                in ignitionCmd:IgnitionCmd;\n                            }\n                            action trigger1 accept ignitionCmd:IgnitionCmd via vehicle.ignitionCmdPort;\n                            flow of IgnitionCmd from trigger1.ignitionCmd to startEngine.ignitionCmd;\n                            action startEngine{\n                                in item ignitionCmd:IgnitionCmd; \n                                out item es:EngineStatus;\n                            }\n                            flow of EngineStatus from startEngine.es to sendStatus.es;\n                            action sendStatus send es via vehicle.statusPort{\n                                in es:EngineStatus;\n                            }\n                            action trigger2 accept es:EngineStatus via driver.p2;\n                        }\n                        part driver : Driver {\n                            perform startVehicle.turnVehicleOn;\n                            perform startVehicle.trigger2;\n                            event occurrence driverReady;\n                        }\n                        part vehicle : Vehicle {\n                            perform startVehicle.trigger1;\n                            perform startVehicle.sendStatus;\n                            event occurrence doorClosed;\n                        }\n                        first vehicle.doorClosed then driver.driverReady;\n                        message of ignitionCmd:IgnitionCmd from driver.turnVehicleOn to vehicle.trigger1;  \n                        message of es:EngineStatus from vehicle.sendStatus to driver.trigger2;\n                    }\n                }\n                occurrence CruiseControl1{\n                    part vehicle_b:>PartsTree::vehicle_b{\n                        port redefines setSpeedPort{\n                            event occurrence setSpeedReceived;\n                        }\n                        part redefines speedSensor{\n                            port redefines speedSensorPort{\n                                event occurrence sensedSpeedSent;\n                            }\n                        }\n                        part redefines vehicleSoftware{\n                            part redefines vehicleController{\n                                part redefines cruiseController{\n                                    port redefines setSpeedPort{\n                                        //analagous to gate: event occurrence bound but may not need this since the port is bound\n                                        event occurrence setSpeedReceived = vehicle_b.setSpeedPort.setSpeedReceived;\n                                    }\n                                    port redefines speedSensorPort{\n                                        event occurrence sensedSpeedReceived;\n                                    }\n                                    port redefines cruiseControlPort{\n                                        event occurrence fuelCmdSent;\n                                    }\n                                }\n                            }\n                        }\n                        part redefines engine{\n                            port redefines fuelCmdPort{\n                                event occurrence fuelCmdReceived;\n                            }\n                        }\n                        message sendSensedSpeed of SensedSpeed\n                            from speedSensor.speedSensorPort.sensedSpeedSent to vehicleSoftware.vehicleController.cruiseController.speedSensorPort.sensedSpeedReceived;\n                        message sendFuelCmd of FuelCmd\n                            from vehicleSoftware.vehicleController.cruiseController.cruiseControlPort.fuelCmdSent to engine.fuelCmdPort.fuelCmdReceived;\n                    }\n                }\n                occurrence CruiseControl2{\n                    part vehicle_b:>PartsTree::vehicle_b{\n                        port redefines setSpeedPort{\n                            event occurrence setSpeedReceived;\n                        }\n                        part redefines speedSensor{\n                            port redefines speedSensorPort{\n                                event sendSensedSpeed.source;\n                            }\n                        }\n                        part redefines vehicleSoftware{\n                            part redefines vehicleController{\n                                part redefines cruiseController{\n                                    port redefines setSpeedPort{\n                                        //analagous to gate: event occurrence bound but may not need this since the port is bound\n                                        event occurrence setSpeedReceived = vehicle_b.setSpeedPort.setSpeedReceived;\n                                    }\n                                    port redefines speedSensorPort{\n                                        event occurrence setSpeedReceived=setSpeedPort.setSpeedReceived;\n                                        then event sendSensedSpeed.target;\n                                    }\n                                    port redefines cruiseControlPort{             \n                                        event sendFuelCmd.source;\n                                    }\n                                }\n                            }\n                        }\n                        part redefines engine{\n                            port redefines fuelCmdPort{\n                                event sendFuelCmd.target;\n                            }\n                        }\n                        message sendSensedSpeed of SensedSpeed;\n                        message sendFuelCmd of FuelCmd;\n                    }\n                }\n            }\n            package Requirements{\n                import RequirementDerivation::*;\n                import ModelingMetadata::*; // incudes status info\n                item marketSurvey;\n                dependency from vehicleSpecification to marketSurvey;\n                \n                requirement vehicleSpecification{\n                    subject vehicle:Vehicle;\n                    requirement <'1'> vehicleMassRequirement: MassRequirement {\n                        doc /* The total mass of the vehicle shall be less than or equal to the required mass.\n                        Assume total mass includes a full tank of gas of 60 kg*/\n                        attribute redefines massRequired=2000 [kg];                     \n                        attribute redefines massActual default vehicle.dryMass + fuelMassActual;\n                        attribute fuelMassActual:>ISQ::mass;\n                        attribute fuelMassMax:>ISQ::mass = 60 [kg];\n                        assume constraint {fuelMassActual==fuelMassMax}\n                    }\n                    \n                    allocate vehicleMassRequirement to PartsTree::vehicle_b.mass;\n                    \n                    requirement <'2'> vehicleFuelEconomyRequirements{\n                        doc /* fuel economy requirements group */\n                        attribute assumedCargoMass:>ISQ::mass;\n                        requirement <'2_1'> cityFuelEconomyRequirement:FuelEconomyRequirement{\n                            redefines requiredFuelEconomy= 10 [km / L];\n                            assume constraint {assumedCargoMass<=500 [kg]}\n                        }\n                        requirement <'2_2'> highwayFuelEconomyRequirement:FuelEconomyRequirement{\n                            redefines requiredFuelEconomy= 12.75 [km / L];\n                            assume constraint {assumedCargoMass<=500 [kg]}\n                            \n                            //StatusInfo is contained in ModelingMetadata library\n                            // StatusKind has values for open, closed, tbd, tbr, tbd\n                            @StatusInfo {\n                                status = StatusKind::closed;     \n                                originator = \"Bob\";\n                                owner = \"Mary\";\n                            }\n                        }\n                    }\n                }\n                requirement engineSpecification {\n                    subject engine1:Engine;\n                    requirement <'1'> engineMassRequirement: MassRequirement {\n                        doc /* The total mass of the engine shall be less than or equal to the required mass.*/\n                        attribute redefines massRequired=200 [kg];                     \n                        attribute redefines massActual = engine1.mass;\n                    }\n                    requirement torqueGenerationRequirement : TorqueGenerationRequirement{\n                        subject generateTorque default engine1.generateTorque;\n                    }\n\n                    requirement drivePowerOutputRequirement : DrivePowerOutputRequirement{\n                        port torqueOutPort{\n                            out torque:Torque;\n                        }\n                    }\n                }\n                // the engine mass requirement is derived from the vehicle mass requirement\n                #derivation connection {\n                    end #original ::> vehicleSpecification.vehicleMassRequirement;\n                    end #derive ::> engineSpecification.engineMassRequirement;\n                }\n\n            }\n        }    \n        package Engine4Cyl_Variant{\n            import ModelingMetadata::*; // incudes refinement\n            part engine:Engine{\n                part cylinders:Cylinder[4..8] ordered;\n            }\n            part engine4Cyl:>engine{\n                part redefines cylinders [4];\n                part cylinder1 subsets cylinders[1];\n                part cylinder2 subsets cylinders[1];\n                part cylinder3 subsets cylinders[1];\n                part cylinder4 subsets cylinders[1];\n            }\n            #refinement dependency engine4Cyl to VehicleConfiguration_b::PartsTree::vehicle_b::engine;\n        }\n        package WheelHubAssemblies{\n            // alternative 1 - w/o explicit nesxted interfaces\n            part wheelHubAssy1{\n                part wheel1:Wheel{\n                    port :>>lugNutCompositePort:LugNutCompositePort {\n                        port lugNutPort :>> lugNutPort [5];\n                    }\n                }\n                part hub1:Hub{\n                    port :>> shankCompositePort:ShankCompositePort {\n                        port shankPort :>> shankPort [5];\n                    }\n                }\n                interface wheelHubInterface:WheelHubInterface\n                    connect wheel1.lugNutCompositePort [1] to hub1.shankCompositePort [1];\n            }\n            // alternative 2 - w multiple nesxted interfaces\n            part wheelHubAssy2{\n                part wheel1:Wheel{\n                    port :>>lugNutCompositePort:LugNutCompositePort {\n                        port lugNutPort :>> lugNutPort [5];\n                    }\n                }\n                part hub1:Hub{\n                    port :>> shankCompositePort:ShankCompositePort {\n                        port shankPort :>> shankPort [5];\n                    }\n                }\n                interface wheelHubInterface:WheelHubInterface\n                    connect lugNutCompositePort ::> wheel1.lugNutCompositePort [1] to shankCompositePort ::> hub1.shankCompositePort [1] {\n                        interface wheelFastenerInterface1 :> wheelFastenerInterface\n                            connect lugNutPort ::> lugNutCompositePort.lugNutPort [5] to shankPort ::> shankCompositePort.shankPort [5];\n                        }\n            }\n            // alternative 3 - w explicit nesxted interfaces\n            part wheelHubAssy3{\n                part wheel1:Wheel{\n                    port lugNutCompositePort :>> lugNutCompositePort {\n                        port lugNutPort [5] :>> lugNutPort {\n                            attribute :>> threadDia = 14 [mm];\n                            attribute :>> threadPitch = 1.5 [mm];\n                        }\n                        port lugNutPort1 [1] :> lugNutPort;\n                        port lugNutPort2 [1] :> lugNutPort;\n                        port lugNutPort3 [1] :> lugNutPort;\n                    }\n}\n                part hub1:Hub{\n                    port shankCompositePort :>> shankCompositePort {\n                        port shankPort [5] :>> shankPort {\n                            attribute :>> threadDia = 14 [mm];\n                            attribute :>> threadPitch = 1.5 [mm];\n                            attribute :>> shaftLength = 70 [mm];\n                        }\n                        port shankPort1 [1] :> shankPort;\n                        port shankPort2 [1] :> shankPort;\n                        port shankPort3 [1] :> shankPort;\n                    }\n}\n                interface wheelHubInterface:WheelHubInterface\n                    connect lugNutCompositePort ::> wheel1.lugNutCompositePort [1] to shankCompositePort ::> hub1.shankCompositePort [1] {\n                        interface wheelFastenerInterface1 :> wheelFastenerInterface\n                            connect lugNutPort ::> lugNutCompositePort.lugNutPort1 to shankPort ::> shankCompositePort.shankPort1 {\n                                attribute :>> maxTorque = 90 * 1.356 [N*m];\n                        }\n                        interface wheelFastenerInterface2 :> wheelFastenerInterface\n                            connect lugNutPort ::> lugNutCompositePort.lugNutPort2 to shankPort ::> shankCompositePort.shankPort2 {\n                                attribute :>> maxTorque = 90 * 1.356 [N*m];\n                        }\n                        interface wheelFastenerInterface3 :> wheelFastenerInterface\n                            connect lugNutPort ::> lugNutCompositePort.lugNutPort3 to shankPort ::> shankCompositePort.shankPort3 {\n                                attribute :>> maxTorque = 90 * 1.356 [N*m];\n                        }\n                }\n            }\n        }\n    }\n    package VehicleAnalysis{\n        import RiskMetadata::*;\n        import RiskLevelEnum::*;\n        // recursive import uses double asterisk **\n        import VehicleConfigurations::VehicleConfiguration_b::**;\n        package FuelEconomyAnalysisModel{\n            import SampledFunctions::SampledFunction;\n              \n            /*\n            This analysis model was provided by Hisashi Miyashita on January 27, 2021\n              We use the simplest fuel consumption analysis model introduced in:\n              Akcelik, R. \"Fuel efficiency and other objectives in traffic system management.\" Traffic Engineering and Control 22.2 (1981): 54-65. \n\n              Fuel consumption rate f can be decomposed to:\n              f = f_a + f_b * tpd_avg,\n              where tpd_avg is average interrupted travel time per unit distance, actually the inverse of the average velocity [t/km];\n              f_a is the best fuel consumption per distance; and\n              f_b is the additional fuel consumption per distance and average travel time, which can be regarded as the idling fuel consumption.\n              Approximately, it is proportional to engine displacement and it ranges from 0.5 to 0.6 [l/hour/litre of engine displacement]\n              according to:\n              Review of the Incidence, Energy Use and Costs of Passenger Vehicle Idling; Gordon W. Taylor, P.Eng. Prepared for the Office of Energy Efficiency, Natural Resources Canada, 2003\n\n              We assume f_a can be approximated to\n              fuel_consumption / distance = BSFC * SGG * required_power_avg * tpd_avg,\n              where required_power_avg is the required power, and it can be approximately derived from:\n                  total_energy == P_req * tpd_avg * distance == 1/2 * mass / tpd_avg^2\n              This part is computed with BestFuelConsumptionPerDistance calc def.\n\n              BSFC means Brake-Specific Fuel Consumption, defined as gram/power.  SGG is the specific gravity of gasoline.\n              The high octane gasoline is about 0.76[l/kg].\n            */\n            \n            attribute def Scenario :> SampledFunction {\n                attribute wayPoint[1..*] {\n                    attribute elapseTime[1] :> ISQ::time;\n                    attribute position[1] :> ISQ::distance;\n                }\n            }\n            \n            calc def FuelConsumption {\n                in bestFuelConsumption: Real;\n                in idlingFuelConsumption: Real; \n                in tpd_avg:>timePerDistance;\n                attribute f = bestFuelConsumption + idlingFuelConsumption * tpd_avg;\n                return dpv :> distancePerVolume = 1/f;\n            }\n            \n            calc def AverageTravelTimePerDistance {\n                in scenario: Scenario;\n                return tpd_avg:>timePerDistance;\n            }\n            calc def TraveledDistance {\n                in scenario: Scenario;\n                return distance:> length;\n            }\n            calc def IdlingFuelConsumptionPerTime {\n                in engine:Engine;\n                attribute idlingFuelConsumptionPerDisplacement: Real = 0.5;\n                return f_a : Real = engine.displacement * idlingFuelConsumptionPerDisplacement;\n            }\n\n            attribute specificGravityOfGasoline: Real = 0.76;\n            calc def BestFuelConsumptionPerDistance {\n                in mass: MassValue;\n                in bsfc: Real;\n                in tpd_avg:> timePerDistance;\n                in distance:>length;\n                attribute required_power_avg:> ISQ::power;\n                constraint {required_power_avg == 1/2 * mass * tpd_avg **(-3) / distance}\n                return f_b : Real = bsfc * specificGravityOfGasoline * required_power_avg * tpd_avg;\n            }\n\n            calc def ComputeBSFC{\n                in engine: Engine;\n                return : Real;\n            }\n\n            analysis fuelEconomyAnalysis  {    \n                subject = vehicle_b; \n                \n                objective fuelEconomyAnalysisObjective {\n                    doc /*estimate the vehicle fuel economy*/\n                    require vehicleSpecification.vehicleFuelEconomyRequirements;\n                }\n                \n                in attribute scenario: Scenario;\n                // define a series of waypoints\n                \n                attribute distance = TraveledDistance(scenario);\n                attribute tpd_avg = AverageTravelTimePerDistance(scenario);\n                attribute bsfc = ComputeBSFC(vehicle_b.engine);\n                attribute f_a = BestFuelConsumptionPerDistance(vehicle_b.mass, bsfc, tpd_avg, distance);\n                attribute f_b = IdlingFuelConsumptionPerTime(vehicle_b.engine);\n\n                return attribute calculatedFuelEconomy:>distancePerVolume=FuelConsumption(f_a, f_b, tpd_avg);\n            }\n        }\n        package ElectricalPowerAnalysis{\n        }\n        package ReliabilityAnalyis{\n        }\n        package VehicleTradeOffAnalysis{\n            /* The following example provides the rationale for selecting the engine4cyl. \n            The rationale and risk are contained in a metadata library. */\n            \n            @Rationale about engineTradeOffAnalysis::vehicle_b_engine4cyl{\n                explanation = VehicleAnalysis::VehicleTradeOffAnalysis::engineTradeOffAnalysis;          \n                text = \"the engine4cyl was evaluated to have a higher objective function compared to the engine6cyl based on the trade-off analyiss\"; \n            }\n            \n            // The following risk for the engine4cyl could have been included as part of the objective evaluaiton criteria\n            \n            @Risk about engineTradeOffAnalysis::vehicle_b_engine4cyl {\n                totalRisk = medium;\n                technicalRisk = medium;\n                scheduleRisk = medium;\n                costRisk = RiskLevelEnum::low;\n            }\n            @Risk about engineTradeOffAnalysis::vehicle_b_engine4cyl::engine::fuelEfficiency {\n                technicalRisk {\n                    probability = 0.3;\n                    impact = 0.5;\n                }\n            }\n            \n                \n            import TradeStudies::*;\n            //evaluation function with criterion engine mass, engine power, and engine cost\n            calc def EngineEvaluation {\n                in engineMass:>ISQ::mass;\n                in enginePower:>ISQ::power; \n                in engineFuelEfficiency:Real;\n                in engineCost:Real;\n                return eval:Real;\n            }\n            calc def EngineEvaluation_4cyl {\n                in engineMass:>ISQ::mass;\n                in enginePower:>ISQ::power;\n                in engineFuelEfficiency:Real;\n                in engineCost:Real;\n                return eval:Real;\n            }\n            calc def EngineEvaluation_6cyl {\n                in engineMass:>ISQ::mass;\n                in enginePower:>ISQ::power;\n                in engineFuelEfficiency:Real;\n                in engineCost:Real;\n                return eval:Real;\n            }\n            analysis engineTradeOffAnalysis:TradeStudy{\n                subject vehicleAlternatives[2]:>vehicle_b;   \n                \n                part vehicle_b_engine4cyl:>vehicleAlternatives{   \n                    part engine redefines engine{\n                        part cylinders :>> cylinders [4];\n                        attribute mass redefines mass=180 [kg];\n                        attribute peakHorsePower redefines peakHorsePower = 180 [W];\n                        attribute fuelEfficiency redefines fuelEfficiency=.6;\n                        attribute cost redefines cost = 1000;                     \n                    }\n                }\n                part vehicle_b_engine6cyl:>vehicleAlternatives{   \n                    part engine redefines engine{  \n                        part cylinders redefines cylinders [6];\n                        attribute mass redefines mass=220 [kg];\n                        attribute peakHorsePower redefines peakHorsePower = 220 [W];\n                        attribute fuelEfficiency redefines fuelEfficiency=.5;\n                        attribute cost redefines cost = 1500;\n                    }\n                }\n                \n                objective :MaximizeObjective;\n                    /*Select vehicle alternative with the engine whose evaluation function returns the max value*/\n                \n                calc :> evaluationFunction{\n                    in part vehicle:>vehicle_b_engine4cyl;\n                    return attribute eval:Real=EngineEvaluation_4cyl (vehicle.engine.mass, vehicle.engine.peakHorsePower, vehicle.engine.fuelEfficiency, vehicle.engine.cost); \n                }\n                calc :> evaluationFunction{\n                    in part vehicle:>vehicle_b_engine6cyl;\n                    return attribute eval:Real=EngineEvaluation_6cyl (vehicle.engine.mass, vehicle.engine.peakHorsePower, vehicle.engine.fuelEfficiency, vehicle.engine.cost); \n                }                                                  \n                return part selectedVehicle:>vehicle_b;\n            }\n        }\n    }\n    package VehicleVerification{\n        import VehicleConfigurations::VehicleConfiguration_b::**;\n        import VerificationCaseDefinitions::*;\n        import VerificationCases1::*;\n        // the following is a model library which contains VerdictKind\n        import VerificationCases::*;\n        import VerificationSystem::*;\n        package VerificationCaseDefinitions{\n            verification def MassTest;\n            verification def AccelerationTest;\n            verification def ReliabilityTest;\n        }\n        package VerificationCases1{\n            verification massTests:MassTest {\n                subject vehicle_uut :> vehicle_b;\n                actor vehicleVerificationSubSystem_1 = verificationContext.massVerificationSystem;\n                objective {\n                    verify vehicleSpecification.vehicleMassRequirement{\n                        redefines massActual=weighVehicle.massMeasured;\n                    }\n                }     \n                // method kinds are test, demo, analyze, should also include inspection, similarity\n               @ VerificationMethod{\n                    kind = (VerificationMethodKind::test, VerificationMethodKind::analyze);\n                }\n                action weighVehicle {\n                    out massMeasured:>ISQ::mass;\n                }\n                then action evaluatePassFail {\n                    in massMeasured:>ISQ::mass;\n                    out verdict = PassIf(vehicleSpecification.vehicleMassRequirement(vehicle_uut));\n                }\n                flow from weighVehicle.massMeasured to evaluatePassFail.massMeasured;\n                return :>> verdict = evaluatePassFail.verdict;\n            }\n        }\n        package VerificationSystem{\n            part verificationContext{\n                perform massTests;\n                part vehicle_UnitUnderTest :> vehicle_b;\n                part massVerificationSystem{\n                    part scale{\n                        perform massTests.weighVehicle;\n                    }\n                    part operator{\n                        perform massTests.evaluatePassFail;\n                    }\n                }\n            }\n        }\n    }\n    package VehicleIndividuals{\n        individual a:VehicleRoadContext_1{\n            timeslice t0_t2_a{\n                snapshot t0_a {             \n                    attribute t0 redefines time=0 [s];\n                    snapshot t0_r:Road_1{\n                        :>>Road::incline =0;\n                        :>>Road::friction=.1;\n                    }\n                    snapshot t0_v:Vehicle_1{\n                        :>>Vehicle::position=0 [m];\n                        :>>Vehicle::velocity=0 [m];\n                        :>>Vehicle::acceleration=1.96 [m/s**2];\n                        // .2 g where 1 g = 9.8 meters/sec^2\n                        snapshot t0_fa:FrontAxleAssembly_1{\n                            snapshot t0_leftFront:Wheel_1;\n                            snapshot t0_rightFront:Wheel_2;\n                        }\n                    }\n                }\n                snapshot t1_a{\n                    attribute t1 redefines time=1 [s];\n                    snapshot t1_r:Road_1{\n                        :>>Road::incline =0;\n                        :>>Road::friction=.1;\n                    }\n                    snapshot t1_v:Vehicle_1{\n                        :>>Vehicle::position=.98 [m];\n                        :>>Vehicle::velocity=1.96 [m/s];\n                        :>>Vehicle::acceleration=1.96 [m/s**2];\n                        // .2 g where 1 g = 9.8 meters/sec^2\n                        snapshot t1_fa:FrontAxleAssembly_1{\n                            snapshot t1_leftFront:Wheel_1;\n                            snapshot t1_rightFront:Wheel_2;\n                        }\n                    }\n                }\n                snapshot t2_a{\n                    attribute t2 redefines time=2 [s];\n                    snapshot t2_r:Road_1{\n                        :>>Road::incline =0;\n                        :>>Road::friction=.1;\n                    }\n                    snapshot t2_v:Vehicle_1{\n                        :>>Vehicle::position=3.92 [m];\n                        :>>Vehicle::velocity=3.92 [m/s];\n                        :>>Vehicle::acceleration=1.96 [m/s**2];\n                        // .2 g where 1 g = 9.8 meters/sec^2\n                        snapshot t2_fa:FrontAxleAssembly_1{\n                            snapshot t2_leftFront:Wheel_1;\n                            snapshot t2_rightFront:Wheel_2;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    package MissionContext{\n        /* Define mission context with mission use cases for vehicle_b */\n        import VehicleConfigurations::VehicleConfiguration_b::**;\n        import ParametersOfInterestMetadata::moe;\n        import TransportPassengerScenario::*;\n        package ContextDefinitions{\n            part def MissionContext:>GenericContext::Context;\n            part def Road;\n            part def Driver{\n                port handPort:HandPort{\n                }\n                exhibit state driverStates{\n                    state initial;\n                    state wait;\n                    transition initial then wait;\n                    //ignition on\n                    transition 'wait-wait-1'\n                        first wait\n                        do send IgnitionCmd (ignitionOnOff=IgnitionOnOff::on) via handPort\n                        then wait;\n                    // ignition off\n                    transition 'wait-wait-2'\n                        first wait\n                        do send IgnitionCmd (ignitionOnOff=IgnitionOnOff::off) via handPort\n                        then wait;\n                }\n            }\n            part def Passenger;\n            \n            requirement transportRequirements;\n            use case def TransportPassenger{\n                objective TransportObjective {\n                    doc /*deliver passenger to destination safely, comfortably, and within acceptable time*/\n                    require transportRequirements;\n                }\n                subject vehicle:Vehicle;\n                actor environment;\n                actor road;\n                actor driver;\n                actor passenger [0..4];\n                include use case getInVehicle_a:>getInVehicle [1..5];\n                include use case getOutOfVehicle_a:>getOutOfVehicle [1..5];\n            }\n            \n            use case getInVehicle:GetInVehicle {\n                action unlockDoor_in [0..1];\n                then action openDoor_in;\n                then action enterVehicle;\n                then action closeDoor_in;\n            }\n            use case def GetInVehicle{\n                subject vehicle:Vehicle;\n                actor driver [0..1];\n                actor passenger [0..1];\n                assert constraint {driver != null xor passenger != null}\n            }\n\n            use case getOutOfVehicle:GetOutOfVehicle {\n                action openDoor_out;\n                then action exitVehicle;\n                then action closeDoor_out;\n                then action lockDoor_out;\n            }\n            use case def GetOutOfVehicle{\n                subject vehicle:Vehicle;\n                actor driver [0..1];\n                actor passenger [0..1];\n                assert constraint {driver != null xor passenger != null}\n            }\n        }\n        package TransportPassengerScenario{\n            import ContextDefinitions::TransportPassenger;\n            \n            // this version uses nesting vs fork and join for concurrent actions\n            use case transportPassenger:TransportPassenger{\n                first start; \n                then action a{\n                    action driverGetInVehicle subsets getInVehicle_a[1];\n                    action passenger1GetInVehicle subsets getInVehicle_a[1];\n                }\n                then action trigger accept ignitionCmd:IgnitionCmd;\n                then action b{\n                    action driveVehicleToDestination;\n                    action providePower;   \n                }\n                then action c{\n                    action driverGetOutOfVehicle subsets getOutOfVehicle_a[1];\n                    action passenger1GetOutOfVehicle subsets getOutOfVehicle_a[1];\n                }\n                then done;\n            }\n            \n            \n            //this version uses forks and joins\n            use case transportPassenger_1:TransportPassenger{\n                // declare actions\n                action driverGetInVehicle subsets getInVehicle_a[1];\n                action passenger1GetInVehicle subsets getInVehicle_a[1];\n                action driverGetOutOfVehicle subsets getOutOfVehicle_a[1];\n                action passenger1GetOutOfVehicle subsets getOutOfVehicle_a[1];\n                action driveVehicleToDestination;\n                action providePower;\n                item def VehicleOnSignal;\n                join join1;\n                join join2;\n                join join3;\n                action trigger accept ignitionCmd:IgnitionCmd;\n                \n                // define control flow\n                first start;               \n                then fork fork1;\n                    then driverGetInVehicle;\n                    then passenger1GetInVehicle;\n                first driverGetInVehicle then join1;\n                first passenger1GetInVehicle then join1;\n                first join1 then trigger;\n                first trigger then fork2;\n                //succession trigger if trigger.ignitionCmd.ignitionOnOff==IgnitionOnOff::on then fork2;\n                \n                fork fork2;\n                    then driveVehicleToDestination;\n                    then providePower;\n                first driveVehicleToDestination then join2;\n                first providePower then join2;\n                first join2 then fork3;\n\n                fork fork3; \n                    then driverGetOutOfVehicle;\n                    then passenger1GetOutOfVehicle;\n                first driverGetOutOfVehicle then join3;\n                first passenger1GetOutOfVehicle then join3;\n\n                first join3 then done;\n            }\n        }\n        \n        part missionContext:ContextDefinitions::MissionContext{\n            #moe attribute transportTime :> ISQ::time;\n            perform transportPassenger;\n            // bind parts to actors of use case\n            part road:ContextDefinitions::Road = transportPassenger.road;\n            part driver:ContextDefinitions::Driver = transportPassenger.driver{\n                perform transportPassenger.a.driverGetInVehicle.unlockDoor_in;\n                perform transportPassenger.a.driverGetInVehicle.openDoor_in;\n                perform transportPassenger.a.driverGetInVehicle.enterVehicle; \n                perform transportPassenger.a.driverGetInVehicle.closeDoor_in;\n                perform transportPassenger.c.driverGetOutOfVehicle.openDoor_out;\n                perform transportPassenger.c.driverGetOutOfVehicle.exitVehicle; \n                perform transportPassenger.c.driverGetOutOfVehicle.closeDoor_out;\n                perform transportPassenger.c.driverGetOutOfVehicle.lockDoor_out;\n                perform transportPassenger.b.driveVehicleToDestination;\n            }\n            part passenger1:ContextDefinitions::Passenger = transportPassenger.passenger {\n                perform transportPassenger.a.passenger1GetInVehicle.unlockDoor_in;\n                perform transportPassenger.a.passenger1GetInVehicle.openDoor_in;\n                perform transportPassenger.a.passenger1GetInVehicle.enterVehicle; \n                perform transportPassenger.a.passenger1GetInVehicle.closeDoor_in;\n                perform transportPassenger.c.passenger1GetOutOfVehicle.openDoor_out;\n                perform transportPassenger.c.passenger1GetOutOfVehicle.exitVehicle; \n                perform transportPassenger.c.passenger1GetOutOfVehicle.closeDoor_out;\n                perform transportPassenger.c.passenger1GetOutOfVehicle.lockDoor_out;\n            }\n            part vehicle_b_1:>vehicle_b = transportPassenger.vehicle{\n                attribute :>> position3dVector = (0,0,0) [spatialCF];\n                perform transportPassenger.b.providePower redefines providePower;\n                perform transportPassenger.trigger;\n            }\n            connect driver.handPort to vehicle_b_1.ignitionCmdPort;\n            connect road to vehicle_b_1.vehicleToRoadPort;\n        }\n    }\n    package VehicleSuperSetModel{\n        /* all of vehicleFamily is included in the superset model to enable subsetting a specific vehicle configuration*/\n        package VariationPointDefinitions {\n            variation part def TransmissionChoices:>Transmission {\n                variant part transmissionAutomatic:TransmissionAutomatic;\n                variant part transmissionManual:TransmissionManual;\n            }\n        }\n        package VehiclePartsTree{\n            import VariationPointDefinitions::*;\n            abstract part vehicleFamily {\n                // variation with nested variation\n                variation part engine:Engine{\n                    variant part engine4Cyl:Engine4Cyl;\n                    variant part engine6Cyl:Engine6Cyl{\n                        part cylinder:Cylinder [6]{\n                            variation attribute diameter:LengthValue{\n                                variant attribute smallDiameter:LengthValue;\n                                variant attribute largeDiagmeter:LengthValue;\n                            }\n                        }\n                    }\n                }\n                // variation point based on variation of part definition\n                part transmissionChoices:TransmissionChoices;\n                // optional variation point\n                part sunroof:Sunroof[0..1];\n                // selection constraint\n                assert constraint selectionConstraint{\n                    (engine==engine::engine4Cyl and transmissionChoices==TransmissionChoices::transmissionManual) xor\n                    (engine==engine::engine6Cyl and transmissionChoices==TransmissionChoices::transmissionAutomatic)\n                }\n                part driveshaft;\n                part frontAxleAssembly;\n                part rearAxleAssembly;\n            }\n        }\n    }\n    package SafetyandSecurityGroups {\n        import VehicleConfigurations::VehicleConfiguration_b::PartsTree::*;\n        package SafetyGroup {\n            /* Parts that contribute to safety. */\n            import vehicle_b::**;\n            filter @Safety;\n        }\n        package SecurityGroup {\n            /* Parts that contribute to security. */\n            import vehicle_b::**;\n            filter @Security;\n        }\n        package SafetyandSecurityGroup {\n            /* Parts that contribute to safety OR security. */\n            import vehicle_b::**;\n            filter @Safety or @Security;\n        }\n        package MandatorySafetyGroup {\n            /* Parts that contribute to safety AND are mandatory. */\n            import vehicle_b::**;\n            filter @Safety and Safety::isMandatory;\n        }\n    }\n    package Views_Viewpoints{\n       package ViewpointDefinitions{\n            viewpoint def BehaviorViewpoint;\n            viewpoint def SafetyViewpoint{\n                frame concern vs:VehicleSafety;\n            }\n            part def SafetyEngineer;\n            concern def VehicleSafety {\n                doc /* identify system safety features */\n                stakeholder se:SafetyEngineer;\n            }\n        }\n        package ViewDefinitions{\n            //Import Views to access rendering method library \n            import Views::*;\n            view def TreeView{\n                render asTreeDiagram;\n            }\n            view def NestedView; \n            view def RelationshipView;\n            view def TableView;\n            view def PartsTreeView:>TreeView {\n                filter @SysML::PartUsage;\n            }\n            view def PartsInterconnection:>NestedView;\n        }\n        package VehicleViews{\n            import ViewpointDefinitions::*;\n            import ViewDefinitions::*;\n            import VehicleConfigurations::VehicleConfiguration_b::*;\n            view vehiclePartsTree_Safety:PartsTreeView{\n                satisfy requirement sv:SafetyViewpoint;\n                expose PartsTree::**;\n                filter @Safety;\n            }\n        }\n    }\n}\n\n",
        "description": "The SysML-V2 code defines a comprehensive model of a vehicle system, detailing its parts, attributes, states, actions, and interactions, enabling systematic analysis, configuration, and verification of vehicle functionalities and behaviors."
    },
    {
        "code": "package VehicleVariabilityModel {\n\n\tpackage DesignModel {\n\t\timport PartDefinitions::*;\n\t\timport PartsTree::*;\n\t\timport ActionDefinitions::*;\n\t\timport ActionTree::*;\n\t\n\t\tpackage PartDefinitions {\n\t\t\tpart def Vehicle;\n\t\t\t\n\t\t    attribute def Diameter;\n\t\t    part def Cylinder {\n\t\t        attribute diameter : Diameter[1];\n\t\t    }\n\t\t\n\t\t    part def Engine;\n\t\t    part def Transmission;\n\t\t    part def Sunroof;\n\t\t\n\t\t    port def AutoPort;\n\t    }\n\t    \n\t    package PartsTree {\n\t    \tpart vehicle : Vehicle {\n\t    \t\tpart engine : Engine[1];\n\t    \t\tpart transmission : Transmission[1];\n\t    \t\tpart sunroof : Sunroof[0..1];\n\t    \t}\n\t    \t\n\t\t    part engine : Engine {\n\t\t        port autoPort : AutoPort;\n\t\t        part cylinder : Cylinder[2..*];\n\t\t    }\n\t\t    \n\t\t    part '4cylEngine' :> engine {\n\t\t    \tpart :>> cylinder[4];\n\t\t    }\n\t\t    \n\t\t    part '6cylEngine' :> engine {\n\t\t    \tpart :>> cylinder[6];\n\t\t    }\n\t\t\n\t\t\tpart transmission : Transmission;\n\t\t    part manualTransmission :> transmission;\n\t\t    part automaticTransmission :> transmission;\n\t    }\n\t\n\t\tpackage ActionDefinitions {   \n\t\t    action def GenerateTorque;\n\t\t    action def AmplifyTorque;\n\t\t    action def ProvidePower;\n\t    }\n\t    \n\t    package ActionTree {    \n\t\t    action generateTorque4Cyl : GenerateTorque;\n\t\t    action generateTorque6Cyl : GenerateTorque;\n\t\t    \n\t\t    action amplifyTorqueManual : AmplifyTorque;\n\t\t    action amplifyTorqueAutomatic : AmplifyTorque;\n\t    }\t\n\t}\n\t\t\n\tpackage '150% Model' {\n\t\timport DesignModel::*;\n\t\n\t\tpackage PartsTree {\n\t\t\n\t\t    // Variation point definitions\n\t\t\n\t\t    variation attribute def DiameterChoices :> Diameter {\n\t\t    \tvariant attribute diameterSmall;\n\t\t    \tvariant attribute diameterLarge;\n\t\t    }\n\t\t\n\t\t    variation part def EngineChoices :> Engine {\n\t\t        variant '4cylEngine';\n\t\t        variant '6cylEngine' {\n\t\t        \tvariation port :>> autoPort {\n\t\t        \t\tvariant port autoPort1;\n\t\t        \t\tvariant port autoPort2;\n\t\t        \t}\n\t\t        \t\n\t\t        \tpart :>> cylinder {\n\t\t        \t\tattribute :>> diameter : DiameterChoices;\n\t\t        \t}\n\t\t        \t\n\t\t          \tassert constraint {\n\t\t            \t(autoPort == autoPort::autoPort1 & cylinder.diameter == cylinder::diameter::diameterSmall) ^\n\t\t             \t(autoPort == autoPort::autoPort2 & cylinder.diameter == cylinder::diameter::diameterLarge)\n\t\t        \t}\n\t\t        }\n\t\t    }\n\t\t\n\t\t    // Part superset model\n\t\t    \n\t\t    abstract part vehicleFamily :> vehicle {\n\t\t    \t// Variation point usage\n\t\t        part :>> engine : EngineChoices[1];\n\t\t        \n\t\t        // Variation point with embedded variant definitions\n\t\t        variation part :>> transmission : Transmission[1] {\n\t\t        \tvariant manualTransmission;\n\t\t        \tvariant automaticTransmission;\n\t\t        }\n\t\t        \n\t\t        assert constraint {\n\t\t            (engine == '4cylEngine' & transmission == transmission::manualTransmission) ^\n\t\t            (engine == '6cylEngine' & transmission == transmission::automaticTransmission)\n\t\t        }\n\t\t        \n\t\t        // Variation point on variant multiplicity (inherited multiplicity is [0..1]) \n\t\t        variation part :>> sunroof {\n\t\t        \tvariant part withSunroof[1];\n\t\t        \tvariant part withoutSunroof[0];\n\t\t        }\n\t\t        \n\t\t        perform ActionTree::providePowerFamily;\n\t\t    }\n\t\t}\n\t\t\n\t\tpackage ActionTree {\n\t\t\n\t\t    // Action superset Model\n\t\t    \n\t\t    action providePowerFamily : ProvidePower {\n\t\t        variation action generateTorque : GenerateTorque {\n\t\t        \tvariant generateTorque4Cyl;\n\t\t        \tvariant generateTorque6Cyl;\n\t\t        }\n\t\t        \n\t\t        variation action amplifyTorque : AmplifyTorque {\n\t\t        \tvariant amplifyTorqueManual;\n\t\t        \tvariant amplifyTorqueAutomatic;\n\t\t        }\n\t\t        \n\t\t\t    assert constraint {\n\t\t\t        (generateTorque == generateTorque::generateTorque4Cyl & \n\t\t\t        \tamplifyTorque == amplifyTorque::amplifyTorqueManual\n\t\t\t        ) xor\n\t\t\t        (generateTorque == generateTorque::generateTorque6Cyl & \n\t\t\t        \tamplifyTorque == amplifyTorque::amplifyTorqueAutomatic\n\t\t\t        )\n\t\t\t    }\t\t   \n\t\t    }\t\t    \n\t\t}\n\t}\n\t\n\tpackage '100% Model' {\n\t\timport '150% Model'::*;\n\t\t\n\t\t// Vehicle instance model\n\t\t\n\t    part vehicle4Cyl :> PartsTree::vehicleFamily {\n\t        part :>> engine = engine::'4cylEngine';\n\t        part :>> transmission = transmission::manualTransmission;\n\t        part :>> sunroof = sunroof::withoutSunroof;\n\t        \n\t        perform action :>> providePowerFamily {\n\t            action :>> generateTorque = generateTorque::generateTorque4Cyl;\n\t            action :>> amplifyTorque = amplifyTorque::amplifyTorqueManual;\n\t        }\n\t    }\n\t}\n}",
        "description": "The SysML-V2 code defines a vehicle variability model with part and action definitions, a parts tree, and action tree, and includes variation points and constraints for engine, transmission, and sunroof configurations, along with corresponding actions and assertions to ensure consistency across different vehicle models."
    },
    {
        "code": "package VehicleMasses {\n\timport ScalarValues::*;\n\timport MassRollup::*;\n\t\n\tpart def CarPart :> MassedThing {\t\t\t\n\t\tattribute serialNumber: String;\n\t}\n\t\n\tpart car: CarPart :> compositeThing {\t\n\t\tattribute vin redefines serialNumber;\n\t\t\n\t\tpart carParts: CarPart[*] redefines subcomponents;\n\t\t\n\t\tpart engine :> simpleThing, carParts {\n\t\t\t//...\n\t\t}\n\t\t\n\t\tpart transmission :> simpleThing, carParts {\n\t\t\t//...\n\t\t}\n\t}\n\n\t// Example usage\n\timport SI::*;\t\n\tpart c :> car {\n\t\tredefines mass = 1000 [kg];\n\t\tpart redefines engine {\n\t\t\tredefines mass = 100 [kg];\n\t\t}\n\t\t\n\t\tpart redefines transmission {\n\t\t\tredefines mass = 50 [kg];\n\t\t}\t\n\t}\n\t\n\t// c.totalMass --> 1150.0 [kg]\n}",
        "description": "The SysML-V2 code defines a hierarchical structure for modeling vehicle components and their masses, allowing for the composition and aggregation of masses through part definitions and attributes, and demonstrating the calculation of total mass based on component masses."
    },
    {
        "code": "package MassRollup {\n\timport NumericalFunctions::*;\n\t\n\tpart def MassedThing {\n\t\tattribute mass :> ISQ::mass; \n\t\tattribute totalMass :> ISQ::mass;\n\t}\n\t\n\tpart simpleThing : MassedThing {\n\t\tattribute redefines totalMass = mass;\n\t}\n\t\n\tpart compositeThing : MassedThing {\n\t\tpart subcomponents: MassedThing[*];\n\t\t\n\t\tattribute redefines totalMass default\n\t\t\tmass + sum(subcomponents.totalMass); \n\t}\n\t\n\tpart filteredMassThing :> compositeThing {\n\t\tabstract attribute minMass :> ISQ::mass;\n\t\t\n\t\tattribute redefines totalMass =\n\t\t\tmass + sum(subcomponents.totalMass.?{in p :> ISQ::mass; p > minMass});\n\t}\n\n}",
        "description": "The SysML-V2 code defines a hierarchical system for calculating and aggregating masses, allowing for simple, composite, and filtered mass calculations based on subcomponents and minimum mass thresholds."
    },
    {
        "code": "package MassConstraintExample {\n\timport ISQ::*;\n\timport SI::*;\n\timport NumericalFunctions::*;\n\t\n\tpart def Engine {\n\t\tattribute m :> mass;\n\t}\n\t\n\tpart def Transmission {\n\t\tattribute m :> mass;\n\t}\n\t\n\tpart def Vehicle1 {\n\t\tattribute m : MassValue = eng.m + trans.m;\n\t\t\n\t\tpart eng : Engine {\n\t\t\tattribute :>> m : MassValue;\n\t\t}\n\t\t\n\t\tpart trans : Transmission {\n\t\t\tattribute :>> m : MassValue;\n\t\t}\n\t}\n\t\n\tpart def Vehicle2 {\n\t\tassert constraint { m == eng.m + trans.m }\n\t\t\n\t\tattribute m : MassValue;\n\t\t\n\t\tpart eng : Engine {\n\t\t\tattribute :>> m : MassValue;\n\t\t}\n\t\t\n\t\tpart trans : Transmission {\n\t\t\tattribute :>> m : MassValue;\n\t\t}\n\t}\n\t\n\tconstraint def MassConstraint3 {\n\t\tin totalMass : MassValue; \n\t\tin partMasses : MassValue[0..*];\n\t\t\t\n\t\ttotalMass == sum(partMasses)\n\t}\n\t\n\tpart def Vehicle3 {\n\t\tassert constraint massConstraint : MassConstraint3 {\n\t\t\tin totalMass = m;\n\t\t\tin partMasses = (eng.m, trans.m);\n\t\t}\n\t\t\n\t\tattribute m : MassValue;\n\t\t\n\t\tpart eng {\n\t\t\tattribute m : MassValue;\n\t\t}\n\t\t\n\t\tpart trans {\n\t\t\tattribute m : MassValue;\n\t\t}\n\t}\n\t\n\tconstraint def MassConstraint4 {\n\t\tin totalMass : MassValue;\n\t\tin partMasses : MassValue[0..*];\n\t}\n\t\n\tconstraint mc : MassConstraint4 {\n\t\tin totalMass : MassValue; \n\t\tin partMasses : MassValue[0..*];\n\t\t\n\t\ttotalMass == sum(partMasses)\n\t}\n\t\n\tpart def Vehicle4 {\n\t\tassert mc {\n\t\t\tin totalMass = m;\n\t\t\tin partMasses = (eng.m, trans.m);\n\t\t}\n\t\t\n\t\tattribute m : MassValue;\n\t\t\n\t\tpart eng : Engine {\n\t\t\tattribute :>> m : MassValue;\n\t\t}\n\t\t\n\t\tpart trans : Transmission {\n\t\t\tattribute :>> m : MassValue;\n\t\t}\n\t}\n\t\n\tconstraint def MassLimit {\n\t\tin mass : MassValue; \n\t\tin maxMass : MassValue;\n\t\t\t\n\t\tmass <= maxMass\n\t}\n\t\n\tpart def Vehicle5 {\n\t\tassert constraint ml : MassLimit {\n\t\t\tin mass = m;\n\t\t\tin maxMass = 2500 [kg];\n\t\t}\n\t\t\n\t\tattribute m : MassValue = eng.m + trans.m;\n\t\t\n\t\tpart eng : Engine {\n\t\t\tattribute :>> m : MassValue;\n\t\t}\n\t\t\n\t\tpart trans : Transmission {\n\t\t\tattribute :>> m : MassValue;\n\t\t}\n\t}\t\n\t\n}",
        "description": "The SysML-V2 code defines various vehicle models with constraints ensuring the total mass of the vehicle is the sum of the masses of its engine and transmission components, and enforces a maximum mass limit for one of the vehicles."
    },
    {
        "code": "package StructuredControlTest {\n\t\n\taction {\n\t\tattribute i : ScalarValues::Integer := 0;\n\t\tattribute b : ScalarValues::Boolean;\n\t\t\n\t\tif i < 0 {\n\t\t\tassign i := 0;\n\t\t} else if i == 0 {\n\t\t\tassign i := 1;\n\t\t} else {\n\t\t\tassign i := i + 1;\n\t\t}\n\t\t\n\t\tif i > 0 {\n\t\t\tassign i := i + 1;\n\t\t}\n\t\t\n\t\tthen action aLoop\n\t\twhile i > 0 {\n\t\t\tassign i := i - 1;\n\t\t} until b;\n\t\t\n\t\tthen while i > 0 {\n\t\t\tassign i := i - 1;\n\t\t}\n\t\t\n\t\tloop {\n\t\t\tassign i := i - 1;\n\t\t} until b;\n\t\t\t\t\n\t\tfor n : ScalarValues::Integer in (1, 2, 3) {\n\t\t\tassign i := i * n;\n\t\t}\n\t}\n}",
        "description": "The SysML-V2 code snippet demonstrates a structured control flow with conditional statements, loops, and a for-each loop, manipulating integer and boolean attributes within an action block."
    },
    {
        "code": "package DependencyTest {\n\t\n\tpackage System {\n\t\tpackage 'Application Layer';\n\t\tpackage 'Service Layer';\n\t\tpackage 'Data Layer';\n\t}\n\t\n\timport System::*;\n\t\n\tdependency Use from 'Application Layer' to 'Service Layer';\n\tdependency from 'Service Layer' to 'Data Layer';\n\t\n\tattribute x;\n\tattribute y;\n\tattribute z;\n\t\n\tdependency z to x, y;\n\t\n}",
        "description": "The SysML-V2 code defines a system architecture with layers and dependencies, imports system packages, and establishes attribute dependencies within a test package."
    },
    {
        "code": "package RequirementTest {\n\tconstraint def C;\n\tconstraint c : C;\n\timport q::**;\n\trequirement def R {\n\t\tassume constraint c1 : C;\n\t\trequire c;\n\t\tdoc /* */\n    \trequirement;\n    \trequirement def <'1'> A {\n    \t\tdoc /* Text */\n    \t\tsubject s;\n    \t}\n\t}\n\trequirement def R1 {\n\t\trequire constraint c1 :>> c;\n\t}\n\tpart p;\n\tpart q {\n\t\trequirement r : R;\n\t\tsatisfy r by p;\n\t\tassert satisfy r by q;\n\t}\n\t\n\trequirement r1 : R1;\n\tnot satisfy r1 by p;\n\tassert not satisfy r1 by q;\n\t\n}",
        "description": "The SysML-V2 code defines a system with requirements, constraints, and parts, specifying relationships such as satisfaction and non-satisfaction between requirements and parts, and includes documentation and assumptions for structured system modeling."
    },
    {
        "code": "package ConjugationTest {\n\tport def P;\n\t\n\tpart def B {\n\t\tport p1: P;\n\t\tport p2: ~P;\n\t}\n\t\n\tconnection def A {\n\t\tend port p1: P;\n\t\tend port p2: ~P;\n\t}\n\t\n\tinterface def I {\n\t\tend p1: P;\n\t\tend p2: ~P;\n\t}\n\t\n\tpart def B1 {\n\t\tpart p {\n\t\t\tport p1: P;\n\t\t\tport p2: ~P;\t\t\n\t\t}\n\t\n\t\tconnection a: A {\n\t\t\tend port p3: P ::> p.p1;\n\t\t\tend port p4: ~P ::> p.p2;\n\t\t}\n\t\tinterface i: I {\n\t\t\tend port p3: P ::> p.p1;\n\t\t\tend port p4: ~P ::> p.p2;\n\t\t}\n\t}\n\t\n}",
        "description": "The SysML-V2 code defines a system with parts, ports, connections, and interfaces, demonstrating how components interact through specified ports and connections, and how interfaces are defined and implemented within the system."
    },
    {
        "code": "package MultiplicityTest {\n\t\n\tpart def P;\n\tattribute n : ScalarValues::Integer = 5;\n\t\n\tpart a[1];\n\tpart b[0..2] : P;\n\tpart c : P[2..*];\n\tpart d[*];\n\t\n\tpart e[n];\n\tpart f[n..*];\n\tpart g[1..n];\n\n\tattribute def A {\n\t\tattribute i :ScalarValues::Integer;\n\t\tattribute x : A[i];\n\t}\n}",
        "description": "The SysML-V2 code defines a package with various parts and attributes, demonstrating different multiplicity constraints such as fixed, bounded, and unbounded ranges, as well as dynamic ranges based on scalar values and recursive attribute definitions."
    },
    {
        "code": "package EnumerationTest {\n\t\n\tattribute def Color {\n\t\tattribute val : ScalarValues::Natural;\n\t}\n\t\n\tenum def ColorKind :> Color {\n\t\tdoc\n\t\t/*\n\t\t * An EnumerationDefinition can contain only EnumerationUsages. However,\n\t\t * it can specialize an AttributeDefinition in order to inherit\n\t\t * common features for its enumeration values.\n\t\t */\n\t\n\t\tenum red {\n\t\t\t:>> val = 0;\n\t\t}\n\t\tenum blue {\n\t\t\t:>> val = 1;\n\t\t}\n\t\tenum green {\n\t\t\t:>> val = 2;\n\t\t}\n\t}\n\t\n\tenum color : ColorKind;\n\tenum color1 = ColorKind::blue;\t// Implicitly typed by ColorKind.\n\tattribute color2 : ColorKind = color1;\n\t\n\tenum def E1 { a; b; c; \n\t\tdoc\n\t\t/*\n\t\t * The \"enum\" keyword is optional for EnumerationUsages used to define the\n\t\t * enumerated values of an EnumerationDefinition.\n\t\t */\n\t}\n\t\n\tenum def E2;\n\t\n\tattribute def Size :> ScalarValues::Real {\n\t\tdoc\n\t\t/*\n\t\t * An EnumerationDefinition can also be used to restrict a supertype to\n\t\t * specific values.\n\t\t */\n\t}\t\t\n\tenum def SizeChoice :> Size {\n\t\t= 60.0;\n\t\t= 70.0;\n\t\t= 80.0;\n\t}\t\n\tenum size: SizeChoice = 60.0;\n\t\n}",
        "description": "The SysML-V2 code defines an enumeration system where `ColorKind` is an enumeration definition that specializes an attribute definition `Color`, allowing it to inherit common features for its enumeration values, and demonstrates various ways to define and use enumerations and attributes, including implicit typing and restricting supertype values."
    },
    {
        "code": "package ConstraintTest {\n\timport ISQ::MassValue;\n\timport SI::kg;\n\timport NumericalFunctions::sum;\n\t\n\tconstraint def MassAnalysis {\n\t\tattribute totalMass: MassValue;\n\t\tattribute componentMasses: MassValue[0..*];\t\t\n\n\t\ttotalMass == sum(componentMasses)\n\t}\n\t\n\tpart def Component {\n\t\tattribute mass: MassValue;\n\t}\n\t\n\tpart vehicle : Component {\t\n\t\tpart engine : Component;\n\t\tpart frontAxleAssembly : Component;\n\t\tpart rearAxleAssembly : Component;\t\n\t}\n\t\t\n\tpart vehicle1a :> vehicle {\n\t\tassert constraint massAnalysis : MassAnalysis {\n\t\t\tattribute redefines totalMass;\n\t\t\tattribute redefines componentMasses;\n\t\t}\n\t\t\n\t\tbind massAnalysis.totalMass = mass;\n\t\tbind massAnalysis.componentMasses[1] = engine.mass;\n\t\tbind massAnalysis.componentMasses[1] = frontAxleAssembly.mass;\n\t\tbind massAnalysis.componentMasses[1] = rearAxleAssembly.mass;\n\t}\n\t\n\tpart vehicle1b :> vehicle {\t\t\n\t\tassert constraint massAnalysis : MassAnalysis {\n\t\t\tattribute redefines totalMass = mass;\n\t\t\tattribute redefines componentMasses = (engine.mass, frontAxleAssembly.mass, rearAxleAssembly.mass);\t\t\n\t\t}\t\n\t}\n\t\t\n\tconstraint def MassAnalysis2 { \n\t\tin totalMass : MassValue;\n\t\tin componentMasses: MassValue[0..*];\n\t\t\n\t\ttotalMass == sum(componentMasses)\n\t}\n\t\n\tpart vehicle2a :> vehicle {\n\t\tassert constraint massConstraint : MassAnalysis2;\n\t\t\n\t\tbind massConstraint.totalMass = mass;\n\t\tbind massConstraint.componentMasses[1] = engine.mass;\n\t\tbind massConstraint.componentMasses[1] = frontAxleAssembly.mass;\n\t\tbind massConstraint.componentMasses[1] = rearAxleAssembly.mass;\n\t}\n\t\t\n\tpart vehicle2b :> vehicle {\n\t\tassert constraint massAnalysis2 : MassAnalysis2 {\n\t\t\tin totalMass = mass;\n\t\t\tin componentMasses = (engine.mass, frontAxleAssembly.mass, rearAxleAssembly.mass);\n\t\t}\n\t}\n\t\n\tconstraint def MassAnalysis3 {\n\t\tin totalMass : MassValue;\n\t\tin componentMasses: MassValue[0..*];\n\t}\n\t\n\tconstraint massAnalysis3 : MassAnalysis3 {\n\t\tin totalMass : MassValue;\n\t\tin componentMasses: MassValue[0..*];\n\t\t\n\t\ttotalMass == sum(componentMasses)\n\t}\n\t\n\tpart vehicle3 :> vehicle {\n\t\tassert massAnalysis3 {\n\t\t\tin totalMass = mass;\n\t\t\tin componentMasses = (engine.mass, frontAxleAssembly.mass, rearAxleAssembly.mass);\n\t\t}\n\t}\n\t\n\tpart vehicle4 :> vehicle {\n\t\tassert constraint { mass == engine.mass + frontAxleAssembly.mass + rearAxleAssembly.mass }\n\t}\n\t\n\tconstraint massLimitation { mass : MassValue; massLimit : MassValue; mass < massLimit }\n\tassert not massLimitation { :>> mass = vehicle3.mass; :>> massLimit = vehicle4.mass; }\n}",
        "description": "The SysML-V2 code defines a system for mass analysis of vehicle components, ensuring that the total mass of a vehicle is equal to the sum of its component masses through various constraint definitions and bindings."
    },
    {
        "code": "package PartTest {\n\t\n\tpart f: A;\n\n\tpublic part def A {\n\t\tpart <'1'> b: B;\n\t\tprotected port c: C;\n\t\treadonly attribute x[0..2];\n\t\tderived ref attribute y :> x;\n\t\tref z : ScalarValues::Integer;\n\t}\n\t\n\tabstract part def <xx> B {\n\t\tpublic abstract part a: A[1..2];\n\t\tpublic abstract part b subsets a;\n\t\tpublic abstract part c[0..1] subsets a;\n\t\tport x: ~C {\n\t\t    port p;\n\t\t    ref port q;\n\t\t}\n\t\tpackage P { }\n\t\t\n\t\taction a1;\n\t\tperform action a2;\n\t\t\n\t\tstate s1;\n\t\texhibit state s2;\n\t}\n\t\n\tprivate port def C {\n\t\tprivate in ref y: A, B;\n\t\talias z1 for y;\n\t\talias z2 for y;\n\t\tport c1 : C;\n\t\tref port c2 : C;\n\t}\n\t\n    part p1 :> p2;\n    part p2 :> p3; \n    part p3 :> p1;\n    \n    part p4 :> p4;\n\t\n}",
        "description": "The SysML-V2 code defines a system structure with parts, ports, and attributes, showcasing inheritance, subsets, and references, while also illustrating abstract parts, package nesting, actions, states, and port aliasing."
    },
    {
        "code": "  /* AAA */\n  //a lexical comment (\"note\") is not a part of model\npackage CommentTest {\n\t// inside package\n\t/*\n*AAA\n * BBB*/\t\n /*\n    *\n    *\n    * AAA  ***   \n    *BBB\n    \t\t\t\t\t\t\t\t*/\n\n   /*\n *       AAAA\n *       BBBB           */\t\n /* AAAA\n \n \n  * BBBB\n *\n * CCCC\n */\n locale \"en_US\" /*\n * AAAA\n * BBBB\n *    CCC DDD    \n */\n\t\n\t/* comment inside a package */\n\tdoc locale \"en_US\" /* Documentation about Package */\n\tcomment cmt /* Named Comment */\t\n\tcomment cmt_cmt about cmt /* Comment about Comment */\n\t\n\tcomment about C /* Documention Comment about Part Def */\n\tpart def C {\n\t\tdoc /* Documentation in Part Def */\n\t\tcomment /* Comment in Part Def */\n\t\tcomment about CommentTest locale \"en_US\" /* Comment about Package */\n\t}\n\t/* abc */\n\tpart def A;\n}",
        "description": "The SysML-V2 code defines a package with various comments, documentation, and part definitions, illustrating how comments and documentation can be associated with different elements within the model."
    },
    {
        "code": "package AliasTest {\n\timport ISQSpaceTime::breadth; // import of an alias\n\tattribute b :> breadth;\n\t\n    part def P1 {\n        port porig1;\n        alias po1 for porig1;\n    }\n\n    part p1 : P1 {\n        port po1 :>> po1;\n    }\n\n    part p2 : P1 {\n        port pdest;\n        alias pd1 for pdest;\n    }\n\n\n    connect p1.po1 to p2.pdest;\n\tconnect p1.po1 to p2.pd1;\n}",
        "description": "The SysML-V2 code defines a package with alias imports, part definitions, and instances connected through ports and aliases, demonstrating the use of aliases for port references and connections between parts."
    },
    {
        "code": "package DefaultValueTest {\n\t\n\tpart def V {\n\t\tattribute m default = 10;\n\t\tattribute n = 20;\n\t}\n\t\n\tpart v1 : V {\n\t\tattribute :>> m = 20;\n\t}\n\t\n\tpart def W :> V {\n\t\tattribute :>> m default = n;\n\t}\n\t\n\tpart v2 = W();\n\t\n}",
        "description": "The SysML-V2 code defines a part type V with attributes m and n, creates instances v1 and v2 with specific attribute values, and demonstrates inheritance and default value assignment in part type W."
    },
    {
        "code": "action def ControlNodeTest {\n\taction A1;\n\tthen J;\n\t\n\taction A2;\n\tthen J;\n\t\n\tjoin J;\n\tthen fork F;\n\tthen B1;\n\tthen B2;\n\t\t\n\taction B1;\n\taction B2;\n}",
        "description": "The SysML-V2 code defines a control flow with actions (A1, A2), a join (J), a fork (F), and subsequent actions (B1, B2), illustrating a sequence where A1 and A2 both lead to J, which then forks into B1 and B2."
    },
    {
        "code": "package ImportTest {\n    package Pkg1 {\n    \timport Pkg2::Pkg21::Pkg211::P211;\n    \timport Pkg2::Pkg21::*;\n    \timport Pkg211::*::**;\n        part p11 : Pkg211::P211;\n        part def P12;\n    }\n\n    package Pkg2 {\n        import Pkg1::*;\n        package Pkg21 {\n        \tpackage Pkg211 {\n        \t\tpart def P211 :> P12;\n        \t}\n        }\n    }\n}",
        "description": "The SysML-V2 code defines a set of packages and their interdependencies, allowing for the importation of specific parts and definitions across different package levels, and establishing relationships between parts such as inheritance."
    },
    {
        "code": "package AllocationTest {\n\tpart def Logical {\n\t\tpart component;\n\t}\n\t\n\tpart def Physical {\n\t\tpart assembly {\n\t\t\tpart element;\n\t\t}\n\t}\n\t\n\tpart l : Logical {\n\t\tpart :>> component;\n\t}\n\tpart p : Physical {\n\t\tpart :>> assembly {\n\t\t\tpart :>> element;\n\t\t}\n\t}\n\t\n\tallocation def A;\n\t\n\tallocation def Logical_to_Physical :> A {\n\t\tend logical : Logical;\n\t\tend physical : Physical;\n\t}\n\t\n\tallocation allocation1 : Logical_to_Physical allocate l to p;\t\n\tallocation allocation2 : Logical_to_Physical allocate (\n\t\tlogical ::> l,\n\t\tphysical ::> p\n\t);\n\n\tallocate l.component to p.assembly.element;\n}",
        "description": "The SysML-V2 code defines logical and physical parts, establishes an allocation relationship between them, and specifies allocations to map logical components to physical elements using different syntaxes."
    },
    {
        "code": "package OccurrenceTest {\n\toccurrence def Occ {\n\t\tattribute a;\n\t\tref occurrence occ1 : Occ;\n\t\toccurrence occ2 : Occ;\n\t\titem x;\n\t\tpart y;\n\t\t\n\t\tindividual snapshot s : Ind;\n\t\ttimeslice t;\n\t}\n\t\n\toccurrence occ : Occ {\n\t\toccurrence o1 : Occ;\n\t\tref occurrence o2 : Occ;\n\t\titem z;\n\t}\n\n\tindividual occurrence def Ind {\n\t\tsnapshot s2;\n\t\ttimeslice t2;\n\t}\n\tindividual occurrence ind : Ind, Occ {\n\t\tsnapshot s3;\n\t\tindividual timeslice t3;\n\t}\n\t\n\tindividual snapshot s4 : Ind;\n\t\n\toccurrence o1 {\n\t  occurrence o2;\n\t}\n}",
        "description": "The SysML-V2 code defines an occurrence hierarchy with attributes, references, and nested occurrences, along with individual occurrences and snapshots, showcasing the modeling of complex relationships and structures within a system."
    },
    {
        "code": "package VariabilityTest {\n\tpart def P {\n\t\tattribute a;\n\t}\n\t\n\tpart def Q :> P;\n\tattribute def B;\n\tvariation part def V :> P {\n\t\tvariant part x : Q {\n\t\t\tattribute b : B :>> a;\n\t\t}\n\t}\n\t\n\tpart q : Q;\n\tvariation part v : P {\n\t\tvariant q {\n\t\t\tattribute b : B :>> a;\n\t\t}\n\t}\n\t\n\tpart y : P = v::q;\n\t\n\tvariation action def A {\n\t\tvariant action a1;\n\t\tvariant action a2;\n\t}\n\t\n\tvariation use case uc1 {\n    \tvariant use case uc11;\n    \tvariant use case uc12;\n    }\n\n    variation analysis a1;\n    \n    variation verification v1;\n    \n    variation requirement r {\n    \tvariant requirement r1;\n    }\n\t\n}",
        "description": "The SysML-V2 code defines a model with parts, attributes, and variations, allowing for the specification of different variants of parts and actions within a system, and includes use cases, analysis, verification, and requirements for managing variability."
    },
    {
        "code": "package MetadataTest {\n\timport 'User Defined Extensions'::*;\n\t\n\tlibrary package 'User Defined Extensions' {\n\t\t\n\t\t#Security enum def ClassificationLevel :> ScalarValues::Natural {\n\t\t\tuncl : ClassificationLevel = 0;\n\t\t\tconf : ClassificationLevel = 1;\n\t\t\t#Security enum secret : ClassificationLevel = 2;\n\t\t}\n\t\t\n\t\tmetadata def Classified {\n\t\t\tref :>> annotatedElement : SysML::Usage;\n\t\t\tref classificationLevel : ClassificationLevel;\n\t\t}\n\t\t\n\t\tmetadata def Security;\n\t}\n\t\n\tref x {\n\t\tmetadata Classified {\n\t\t\tclassificationLevel = ClassificationLevel::conf;\n\t\t}\n\t}\n\t\n\tref y {\n\t\t@Classified {\n\t\t\tclassificationLevel = ClassificationLevel::conf;\n\t\t}\n\t\t@Security;\n\t}\n\t\n\tprivate ref #Classified #Security z1;\n\tabstract #Classified z2;\n\t\n\tref z {\n\t    #Security #Classified metadata Classified {\n\t        classificationLevel = ClassificationLevel::secret;\n\t    }\n\t}\t\n\t\n}",
        "description": "The SysML-V2 code defines a library package for user-defined security extensions, including an enumeration for classification levels and metadata definitions for classifying elements, and demonstrates various ways to apply these metadata annotations to references within a test package."
    },
    {
        "code": "package ParameterTest {\n\tattribute def A {\n\t\tattribute x : ScalarValues::String;\n\t\tattribute y : A;\n\t}\n\t\n\tattribute a : A;\n\t\n\tcalc def F { in p : A; in q : ScalarValues::Integer; return :  ScalarValues::Integer; }\n\t\n\tattribute f = F(a, 2);\n\tattribute g = F(q = 1, p = a);\n\t\n\tattribute b = A(y=a, x=\"\"); \n\tattribute c = A(\"test2\");\n}",
        "description": "The SysML-V2 code defines a package with attributes, calculations, and attribute assignments, demonstrating the use of scalar values, nested attributes, and parameterized function calls."
    },
    {
        "code": "package TradeStudyTest {\n\timport ScalarValues::Real;\n\timport TradeStudies::*;\n\t\n\tpart def Engine;\n\tpart engine1: Engine;\n\tpart engine2: Engine;\n\t\n\tanalysis engineTradeStudy : TradeStudy {\n\t\tsubject : Engine[1..*] = (engine1, engine2);\n\t\tobjective : MaximizeObjective;\n\n\t\tcalc :>> evaluationFunction {\n\t\t\tin part : Engine;\n\t\t\treturn : Real;\n\t\t}\n\t\t\n\t\treturn part : Engine;\n\t}\n\t\n}",
        "description": "The SysML-V2 code defines a trade study analysis for comparing two engine parts, utilizing an evaluation function to determine the best engine based on a maximization objective."
    },
    {
        "code": "action def DecisionTest {\n\tattribute x = 1;\n\t\n\tdecide 'test x';\n\tif x == 1 then A1; \n\tif x > 1 then A2;\n\telse A3; \n\t\n\tthen decide; \n\tif true then A1;\n\tif false then A2;\n\t\n\taction A1;\n\taction A2;\n\taction A3;\n\t\n\tsuccession S first A1 \n\t\tif x == 0 then A2;\n\t\t\n\tfirst A3;\n\t\tif x > 0 then 'test x';\n}",
        "description": "The SysML-V2 code defines a decision-making action with conditional branches based on the value of an attribute `x`, executing different actions (`A1`, `A2`, `A3`) based on the conditions, and managing a succession of actions with further conditional logic."
    },
    {
        "code": "package TextualRepresentationTest {\n\timport ScalarValues::Real;\n\t\n\titem def C {\n\t    attribute x: Real;\n\t    assert constraint x_constraint {\n\t\t    rep inOCL language \"ocl\" \n\t\t        /* self.x > 0.0 */\n\t    }\n\t}\n\t\n\taction def setX {\n\t\tin c : C;\n\t\tin newX : Real;\n\t\t\n\t    language \"alf\" \n\t        /* c.x = newX;\n\t         * WriteLine(\"Set new x\");\n\t         */\n\t}\n\t\n}",
        "description": "The SysML-V2 code defines a class `C` with an attribute `x` constrained to be positive, and an action `setX` to update `x` and print a message, using OCL for constraints and ALF for action implementation."
    },
    {
        "code": "package CalculationExample {\n\timport ISQ::*;\n\timport NumericalFunctions::*;\n\t\n\tpart def VehiclePart {\n\t\tattribute m : MassValue;\n\t}\n\t\n\tpart def Vehicle :> VehiclePart;\n\t\n\tpart vehicle : Vehicle {\t\t\n\t\tpart eng : VehiclePart;\t\t\n\t\tpart trans : VehiclePart;\n\t\tattribute ::> m = ms.totalMass;\n\t}\n\t\n\tcalc def MassSum {\n\t\tin partMasses : MassValue[0..*];\n\t\treturn totalMass : MassValue = sum(partMasses);\n\t}\n\t\n\tcalc ms: MassSum {\n\t\tin partMasses = (vehicle.eng.m, vehicle.trans.m);\n\t\treturn totalMass;\n\t}\n\t\n\tpart vehicles[*] = (vehicle, vehicle);\n\tattribute masses1[*] = (vehicles as VehiclePart).m;\n\tattribute masses2[*] = (vehicles as vehicle).m;\n}",
        "description": "The SysML-V2 code defines a system for calculating the total mass of vehicle parts and vehicles, utilizing part definitions, attributes, and calculation definitions to sum masses and assign them to higher-level parts."
    },
    {
        "code": "package ItemTest {\n\t\n\titem f: A;\n\n\tpublic item def A {\n\t\titem b: B;\n\t\tprotected ref part c: C;\n\t}\n\t\n\tabstract item def B {\n\t\tpublic abstract part a: A;\n\t}\n\t\n\tprivate part def C {\n\t\tprivate in ref y: A, B;\n\t}\n\t\n\tport def P {\n\t\tin item a1: A;\n\t\tout item a2: A;\n\t}\n\t\n}",
        "description": "The SysML-V2 code defines a structured model with items, parts, and ports, establishing relationships and access levels between abstract and concrete elements, enabling complex interactions and data flow within the system."
    },
    {
        "code": "package AnalysisTest {\n\n\tpart def V {\n\t\tm;\n\t}\n\t\n\tpart vv : V;\n\t\n\trequirement def AnalysisObjective {\n\t\tdoc /* ... */\n\t}\n\n\tanalysis def AnalysisCase {\n\t\tsubject v : V;\n\t\t\n\t\tobjective obj : AnalysisObjective { \n\t\t\tsubject = result;\n\t\t}\n\t\t\n\t\tv.m\n\t}\n\t\n\tanalysis def AnalysisPlan {\n\t\tsubject v : V;\n\t\t\n\t\tobjective {\n\t\t\tdoc /* ... */\n\t\t}\n\t\t\n\t\tanalysis analysisCase : AnalysisCase { return mass; }\n\t}\n\t\n\tpart analysisContext {\n\t\tanalysis analysisPlan : AnalysisPlan {\n\t\t\tsubject v = vv;\n\t\t}\n\t}\n}",
        "description": "The SysML-V2 code defines a system analysis framework with parts, requirements, and analysis cases, where an analysis plan specifies the subject and objectives, and an analysis context applies the plan to a specific part instance."
    },
    {
        "code": "package UseCaseTest {\n\n\tpart def System;\t\n\tpart def User;\n\t\n\tuse case def UseSystem {\n\t\tsubject system : System;\n\t\tactor user : User;\n\t\t\n\t\tobjective  { \n\t\t\t/* Goal */\n\t\t}\n\t\t\n\t\tinclude use case uc1 : UC1;\t\n\t\tinclude use case uc2 {\n\t\t\tsubject = system;\n\t\t\tactor user = UseSystem::user;\n\t\t}\n\t}\n\t\n\tuse case def UC1;\n\t\n\tpart user : User;\n\t\n\tuse case uc2 {\n\t\tactor :>> user;\n\t}\n\t\n\tuse case u : UseSystem;\n\t\n\tpart system : System {\n\t\tinclude uc2;\n\t\tperform u;\n\t}\n\t\n}",
        "description": "The SysML-V2 code defines a system and user parts, outlines a use case for system usage involving specific actors and objectives, includes other use cases, and demonstrates interactions between parts through use case inclusions and performances."
    },
    {
        "code": "package ConnectionTest {\n\t\n\tpart p {\n\t\tpart x {\n\t\t\tpart x1;\n\t\t}\n\t}\n\t\n\tpart def P {\n\t\tpart y;\n\n\t\tconnect p to y;\n\t\t\n\t\tpart p1 :> p;\n\t\n\t\tconnect p1.x to y;\n\t\tconnect p1.x.x1 to y;\n\t}\n\n\tabstract connection def C {\n\t\tpart p;\n\t\tend end1;\n\t\tend end2;\n\t\tend end3;\n\t}\n\t\n\tpart d1;\n\tpart d2;\n\tpart d3;\n\tpart d4;\n\t\n\tconnection bus : C connect (d1, d2, d3, d4);\n\t\n\tconnection : C {\n\t    end :>> end1 ::> d1;\n\t    end end2 ::> d2;\n\t    end end3 ::> d3;\n\t}\n\t\n\tconnection {\n\t\tpart q;\n\t\tend end1 ::> d1 :> q;\n\t\tend end2 ::> d2;\n\t}\n\t\n\tabstract flow def F;\n\t\n\tmessage : F from p to p;\n}",
        "description": "The SysML-V2 code defines a system structure with parts, connections, and flows, demonstrating hierarchical part composition, connection establishment between parts, and abstract connection and flow definitions with specific instances and endpoints."
    },
    {
        "code": "package StateTest {\n\tattribute def Sig {\n\t\tx;\n\t}\n\tattribute def Exit;\n\t\n\tpart p;\n\t\n\taction act;\n\t\n\tstate def S {\n\t\tdo action A;\n\t\tentry; then S1;\n\t\t\n\t\tstate S1;\n\t\t\taccept s : Sig\n\t\t\tdo action D\n\t\t\tthen S2;\n\t\t\t\t\n\t\tstate S2 {\n\t\t\tdo send Sig(T.s.x) to p;\n\t\t\tstate S3;\n\t\t}\n\t\taccept Exit then done;\n\t\t\n\t\ttransition\n\t\t\tfirst S1\n\t\t\taccept s : Sig\n\t\t\tdo action D\n\t\t\tthen S2.S3;\n\t\t\n\t\ttransition T\n\t\t\tfirst S2.S3\n\t\t\taccept s : Sig via p\n\t\t\tif true\n\t\t\tdo send s to p\n\t\t\tthen S1;\n\t\t\t\n\t\texit act;\n\t}\n\t\n\tstate s parallel {\n\t\tstate s1;\n\t\tstate s2;\n\t}\n\t\n\tstate s4 {\n\t\tdo action a;\n  \t\taction c;\n\t}\n\t\n\tstate s5 :> s4 {\n  \t\tdo action b :>> c;\n\t}\n\t\n}",
        "description": "The SysML-V2 code defines a state machine with various states, transitions, and actions, allowing for entry and exit actions, state transitions based on signals, and parallel states, demonstrating a complex system behavior model."
    },
    {
        "code": "package Q {\n  part def F {\n  \tpart a : A;\n  }\n  \n  part f : F;\n  \n  part def A {\n    part g = f.a;\n  }\n  \n  part def B {\n  \tpart f : F;\n  \tpart a : A;\n  }\n  \n  part def C {\n\tpart b : B {\n\t  connect f.a to a.g;\n\t  bind f.a = a.g;\n\t}\n  \n\tpart c subsets b.f {\n\t  \tpart aa subsets a;\n\t}\n\t\n\tflow b.f.a to c.aa;\n  }\n  \n  part e1 {\n  \tattribute x : E;\n  \t// Ensure that \"e1\" resolves correctly.\n  \tbind e1.x = E::e2;\n  }\n  \n  enum def E {\n  \tenum e1;\n  \tenum e2;\n  }\n  \n  part g = A().g.g.g;\n\t\n}\n",
        "description": "The SysML-V2 code defines a complex system with parts, connections, bindings, and flows, demonstrating hierarchical relationships, attribute bindings, and recursive part references within a structured package."
    },
    {
        "code": "package P1 {\n\tpart def A;\n}\n\npackage P2 {\n\timport P1::*;\n\tpart a : A;\n}\n\nimport P2::*;\n\npackage P3 {\n\tpart b subsets a;\n}",
        "description": "The SysML-V2 code defines a hierarchical structure of packages and parts, allowing for the importation and specialization of part definitions across different packages, with P3 inheriting and specializing a part from P2, which itself imports and uses a part definition from P1."
    },
    {
        "code": "package ViewTest {\n\tpackage P {\n\t\tpublic part p1;\n\t\tprivate part p2;\n\t}\n\t\n\tpart def S;\n\t\n\tconcern def C {\n\t\tstakeholder s : S;\n\t}\n\t\n\tconcern c : C {\n\t\tstakeholder s1;\n\t}\n\t\n\tviewpoint def VP {\n\t\tframe c;\n\t}\n\t\n\trendering def R;\n\t\n\trendering r : R;\n\t\n\tview def V {\n\t\tviewpoint vp: VP {\n\t\t\tframe concern c1;\n\t\t\tconcern c2;\n\t\t}\n\t\trender rendering r1: R[0..1]; \n\t\t\n\t\tview v: V[0..*] {\n\t\t\texpose P::*;\n\t\t\trender r;\n\t\t\t\n\t\t\trendering r2;\n\t\t\t\n\t\t\talias vp1 for p1;\n\t\t\t// Note: \"expose\" imports all.\n\t\t\talias vp2 for p2;\n\t\t}\n\t}\n\n}",
        "description": "The SysML-V2 code defines a structured view of a system, including parts, concerns, viewpoints, and renderings, with specific visibility and interaction rules between these elements."
    },
    {
        "code": "package AssignmentTest {\n\t\n\tpart def Counter {\n\t\tattribute count : ScalarValues::Integer := 0;\n\t\t\n\t\taction incr {\n\t\t\tassign count := count + 1;\n\t\t}\n\t\t\n\t\taction decr {\n\t\t\tassign count := count - 1;\n\t\t}\n\t}\n\t\n\tattribute def Incr;\n\tattribute def Decr;\n\t\n\tstate def Counting {\n\t\tpart counter : Counter;\n\t\tentry assign counter.count := 0;\n\t\t\n\t\tthen state wait;\n\t\taccept Incr\n\t\t\tthen increment;\n\t\taccept Decr\n\t\t\tthen decrement;\n\t\t\n\t\tstate increment {\n\t\t\tdo assign counter.count := counter.count + 1;\n\t\t}\n\t\tthen wait;\n\t\t\n\t\tstate decrement {\n\t\t\tdo assign counter.count := counter.count - 1;\n\t\t}\n\t\tthen wait;\n\t}\n\t\n\tcalc def Increment { \n\t\tin c : Counter;\n\t\treturn : Counter;\n\t\t\n\t\tperform c.incr;\n\t\tc\n\t}\n\t\n\taction a {\n\t\tstate counting : Counting;\n\t\tassign counting.counter.count := counting.counter.count + 1;\n\t\tassign counting.counter.count := Increment(counting.counter).count;\n\t}\n}",
        "description": "The SysML-V2 code defines a `Counter` part with increment and decrement actions, a `Counting` state machine that manages the counter's state transitions upon receiving `Incr` and `Decr` events, and an `Increment` calculation that performs the increment action on a counter, all within the `AssignmentTest` package."
    },
    {
        "code": "package VerificationTest {\n\n\tpart def V {\n\t\tm : ScalarValues::Integer;\n\t}\n\t\n\tpart vv : V;\n\t\n\trequirement def R {\n\t\tdoc /* ... */\n\t}\n\t\n\trequirement r : R;\n\n\tverification def VerificationCase {\t\t\n\t\tsubject v : V;\t\n\t\tobjective {\n\t\t\tverify requirement : R;\n\t\t}\n\t\t\n\t\tVerificationCases::PassIf(v.m == 0)\n\t}\n\t\n\tverification def VerificationPlan {\n\t\tsubject v : V;\n\t\t\n\t\tobjective {\n\t\t\tverify r;\n\t\t}\n\t\t\n\t\tverification verificationCase : VerificationCase;\n\t}\n\t\n\tpart verificationContext {\n\t\tverification verificationPlan : VerificationPlan {\n\t\t\tsubject v = vv;\n\t\t}\n\t}\n}",
        "description": "The SysML-V2 code defines a system with a part `V` having an integer attribute `m`, a requirement `R`, and verification cases and plans to check if `m` equals zero, linking these verifications to the requirement and a specific instance `vv` of `V`."
    },
    {
        "code": "package ActionTest {\n\taction def A{ in x; }\n\t\n\taction a: A { \n\t\tfirst start;\n\t\t\n\t\taction b { in y = x; }\n\t\t\n\t\tbind x = b.y;\n\t}\n\t\n\tattribute def S;\n\t\n\taction a1 {\n\t\tfirst start;\t\t\n\t\tthen merge m;\n\t\tthen accept S;\n\t\tthen accept sig after 10[SI::s]; \n\t\tthen accept at Time::Iso8601DateTime(\"2022-01-30T01:00:00Z\");\n\t\t\n\t\tthen send S() to b;\n\t\tthen accept when b.f;\n\t\tthen decide;\n\t\t\tif true then m;\n\t\t\telse done;\n\t}\n\t\n\taction b {\n\t\tattribute f : ScalarValues::Boolean;\n\t\tref action a : A;\n\t}\n\t\n}",
        "description": "The SysML-V2 code defines actions with inputs and attributes, establishes bindings between actions, and sequences actions with conditional branching based on decisions and external conditions."
    },
    {
        "code": "// State Space Representation EV example\npackage EVSample {\n    import SI::*;\n    import StateSpaceRepresentation::*;\n\n    attribute <'A\u22c5h'> 'ampere hour'  : ElectricChargeUnit = A*h;\n\n    part def Vehicle {\n        attribute mass :> ISQ::mass;\n\n        attribute def VehicleInput :> Input {\n            attribute force :> ISQ::force;\n        }\n\n        attribute def VehicleOutput :> Output {\n            attribute accel :> ISQ::acceleration;\n            attribute velocity :> ISQ::speed;\n            attribute distance :> ISQ::distance;\n        }\n\n        attribute def VehicleState :> StateSpace {\n            attribute velocity :> ISQ::speed;\n            attribute distance :> ISQ::distance;\n        }\n    }\n\n    part def Battery {\n        attribute baseVoltage :> ISQ::electricPotential;\n        attribute socInit: ScalarValues::Real;\n        attribute capacity :> ISQ::electricCharge;\n        attribute internalResistance :> ISQ::resistance;\n\n        attribute def BatteryInput :> Input {\n            attribute current :> ISQ::electricCurrent;\n        }\n\n        attribute def BatteryOutput :> Output {\n            attribute voltage :> ISQ::electricPotential;\n        }\n\n        attribute def BatteryState :> StateSpace {\n            attribute soc: ScalarValues::Real;\n        }\n\n    }\n\n    part def Motor {\n        torquePerCurrent :> Quantities::scalarQuantities = ISQ::torque / ISQ::electricCurrent;\n\n        attribute motR :> ISQ::resistance;\n        attribute motL :> ISQ::inductance;\n\n        attribute def MotorInput :> Input {\n            attribute voltage :> ISQ::electricPotential;\n            attribute friction :> ISQ::torque;\n        }\n\n        attribute def MotorOutput :> Output {\n            attribute current :> ISQ::electricCurrent;\n            attribute torque :> ISQ::torque;\n        }\n\n        attribute def MotorState :> StateSpace {\n            attribute current :> ISQ::electricCurrent;\n        }\n    }\n\n    part def Tire {\n        attribute radius :> ISQ::length;\n        attribute moment :> ISQ::momentOfInertia;\n\n        attribute def TireInput :> Input {\n            attribute torque :> ISQ::torque;\n            attribute accel :> ISQ::acceleration;\n        }\n\n        attribute def TireOutput :> Output {\n            attribute force :> ISQ::force;\n            attribute outTorque :> ISQ::torque;\n        }\n    }\n\n    requirement def VehicleRequirement {\n        in vehicle : Vehicle;\n    }\n\n    analysis def VehicleAnalysis {\n        subject vehicle : Vehicle;\n        requirement vehicleRequirement : VehicleRequirement;\n    }\n\n\n    requirement def RangeRequirement :> VehicleRequirement {\n        doc /* The range of EV must be longer than the required spec under the flat road. */\n        attribute actualRange : LengthValue;\n        attribute requiredRange : LengthValue;\n\n        require constraint { actualRange >= requiredRange }\n    }\n\n    analysis def RangeAnalysis :> VehicleAnalysis {\n    \treturn simulatedRange : LengthValue;\n    \t\n        requirement rangeRequirement :>> vehicleRequirement : RangeRequirement;\n\n        objective rangeAnalysisObjective {\n            doc /* This analysis is to estimate the range of\n                 * the EV by simulating the vehicle driving under the compact vehicle regulation.\n                 */\n            require rangeRequirement {\n                :>> actualRange = simulatedRange;\n            }\n        }\n    }\n\n    requirement def EfficiencyRequirement :> VehicleRequirement {\n        doc /* The efficiency of EV must be better than the required spec. */\n        attribute actualEfficiency;\n        attribute requiredEfficiency;\n\n        require constraint { actualEfficiency >= requiredEfficiency }\n    }\n\n    analysis def EfficiencyAnalysis :> VehicleAnalysis {\n    \treturn simulatedEfficiency;\n    \t\n        requirement efficiencyRequirement :>> vehicleRequirement : EfficiencyRequirement;\n\n        objective efficiencyAnalysisObjective {\n            require efficiencyRequirement {\n                attribute :>> actualEfficiency = simulatedEfficiency;\n            }\n        }\n    }\n\n    requirement def MaxSpeedRequirement :> VehicleRequirement {\n        doc /* The maximum speed of EV must be larger than the required spec. */\n        attribute actualMaxSpeed :> ISQ::speed;\n        attribute requiredMaxSpeed :> ISQ::speed;\n    }\n\n    analysis def MaxSpeedAnalysis :> VehicleAnalysis {\n    \treturn simulatedMaxSpeed;\n    \t\n        requirement maxSpeedRequirement :>> vehicleRequirement : MaxSpeedRequirement;\n\n        objective maxSpeedAnalysisObjective {\n            require maxSpeedRequirement {\n                attribute :>> actualMaxSpeed = simulatedMaxSpeed;\n            }\n        }\n    }\n\n\n    part vehicle : Vehicle {\n        attribute :>> mass default 1000[kg];\n\n        /* airFrictionCoefficient [kg / m] = 1/2 * rho[kg/m^3] * Cd * S[m^2],\n         * where rho is air density, S is front projected area. */\n        attribute airFrictionCoefficient = 0.2;\n\n        attribute efficiency;\n\n        action vehicleBehavior : ContinuousStateSpaceDynamics {\n            in input : VehicleInput;\n            out output : VehicleOutput;\n            :>> stateSpace : VehicleState;\n        }\n        \n        part battery: Battery {\n            :>> baseVoltage = 300[V];\n            :>> capacity = 50['A\u22c5h'];\n            :>> socInit = 0.8;\n            :>> internalResistance = 1.8['\u03a9'];\n            action batteryBehavior : ContinuousStateSpaceDynamics {\n                in input : BatteryInput;\n                out output : BatteryOutput;\n                :>> stateSpace : BatteryState;\n            }\n        }\n\n        flow battery.batteryBehavior.output.voltage to motor.motorBehavior.input.voltage;\n        flow motor.motorBehavior.output.current to battery.batteryBehavior.input.current;\n\n        part motor: Motor {\n            :>> motR = 4['\u03a9'];\n            :>> motL = 0.2[H];\n\n            action motorBehavior : ContinuousStateSpaceDynamics {\n                in input : MotorInput;\n                out output : MotorOutput;\n                :>> stateSpace : MotorState;\n            }\n        }\n\n        flow motor.motorBehavior.output.torque to tire.tireBehavior.input.torque;\n        flow vehicleBehavior.output.accel to tire.tireBehavior.input.accel;\n\n        part tire: Tire {\n            :>> moment default 300['kg\u22c5m\u00b2'];\n            :>> radius default 0.7[m];\n            action tireBehavior : ContinuousStateSpaceDynamics {\n                in input : TireInput;\n                out output : TireOutput;\n            }\n        }\n\n        flow tire.tireBehavior.output.outTorque to motor.motorBehavior.input.friction;\n        flow tire.tireBehavior.output.force to vehicleBehavior.input.force;\n    }\n\n    part vehicle_compact :> vehicle {\n        attribute :>> mass = 800[kg];\n        part :>> tire {\n            :>> moment = 200['kg\u22c5m\u00b2'];\n            :>> radius = 0.5[m];\n        }\n    }\n\n    part smallEVRangeContext {\n        requirement smallEVRequirement : VehicleRequirement {\n            doc /* The small EVs must be ligher than 900[kg] */\n            in :>> vehicle = vehicle_compact;\n            /*  To comform with the regulation and the battery mass will impact it. */\n            assume constraint { vehicle.mass < 900[kg] }\n        }\n\n        analysis smallEVAnalysis : VehicleAnalysis {\n            subject :>> vehicle :> vehicle_compact;\n            requirement :>> vehicleRequirement = smallEVRequirement;\n        }\n\n        requirement <C1> rangeRequirementSmall :> smallEVRequirement : RangeRequirement {\n            doc /* The small EVs must run longer than 130km */\n            attribute :>> requiredRange = 130[km];\n        }\n\n        analysis rangeAnalysisSmall :> smallEVAnalysis : RangeAnalysis {\n            requirement :>> rangeRequirement = rangeRequirementSmall;\n            return simulatedRange = vehicle.vehicleBehavior.output.distance;\n        }\n\n        requirement <C2> efficiencyRequirementSmall :> smallEVRequirement : EfficiencyRequirement {\n            doc /* The target efficiency of small EVs is 0.9. */\n            attribute :>> requiredEfficiency = 0.9;\n        }\n\n        analysis efficiencyAnalysisSmall :> smallEVAnalysis : EfficiencyAnalysis {\n            requirement :>> efficiencyRequirement = efficiencyRequirementSmall;\n\n            return simulatedEfficiency = vehicle.efficiency;\n        }\n\n        requirement <C3> maxSpeedRequirementSmall :> smallEVRequirement : MaxSpeedRequirement {\n            doc /* The target maximum speed of small EVs is 130 [km/h]. */\n            attribute :>> requiredMaxSpeed = 130 [km/h];\n        }\n\n        analysis maxSpeedAnalysisSmall :> smallEVAnalysis : MaxSpeedAnalysis {\n            requirement :>> maxSpeedRequirement = maxSpeedRequirementSmall;\n            out voltage :> ISQ::electricPotential = vehicle.battery.batteryBehavior.output.voltage;\n            return simulatedMaxSpeed = vehicle.vehicleBehavior.output.velocity;\n        }\n    }\n\n    part vehicle_large :> vehicle {\n        attribute :>> mass = 1100[kg];\n        part :>> tire {\n            :>> moment = 300['kg\u22c5m\u00b2'];\n            :>> radius = 0.7[m];\n        }\n    }\n\n    part largeEVRangeContext {\n        requirement largeEVRequirement : VehicleRequirement {\n            doc /* The large EVs must be ligher than 900[kg] */\n            in :>> vehicle = vehicle_large;\n            /*  To comform with the regulation and the battery mass will impact it. */\n            assume constraint { vehicle.mass < 1200[kg] }\n        }\n\n        analysis largeEVAnalysis : VehicleAnalysis {\n            subject :>> vehicle :> vehicle_large;\n            requirement :>> vehicleRequirement = largeEVRequirement;\n        }\n\n        requirement <L1> rangeRequirementLarge :> largeEVRequirement : RangeRequirement {\n            doc /* The large EVs must run longer than 200km */\n            attribute :>> requiredRange = 200[km];\n        }\n\n        analysis rangeAnalysisLarge :> largeEVAnalysis : RangeAnalysis {\n            requirement :>> rangeRequirement = rangeRequirementLarge;\n            return simulatedRange = vehicle.vehicleBehavior.output.distance;\n        }\n\n        requirement <L2> efficiencyRequirementLarge :> largeEVRequirement : EfficiencyRequirement {\n            doc /* The target efficiency of large EVs is 0.8. */\n            attribute :>> requiredEfficiency = 0.8;\n        }\n\n        analysis efficiencyAnalysisLarge :> largeEVAnalysis : EfficiencyAnalysis {\n            requirement :>> efficiencyRequirement = efficiencyRequirementLarge;\n\n            return simulatedEfficiency = vehicle.efficiency;\n        }\n\n        requirement <L3> maxSpeedRequirementLarge :> largeEVRequirement : MaxSpeedRequirement {\n            doc /* The target maximum speed of large EVs is 140 [km/h]. */\n            attribute :>> requiredMaxSpeed = 140 [km/h];\n        }\n\n        analysis maxSpeedAnalysisLarge :> largeEVAnalysis : MaxSpeedAnalysis {\n            requirement :>> maxSpeedRequirement = maxSpeedRequirementLarge;\n            out voltage = vehicle.battery.batteryBehavior.output.voltage;\n            return simulatedMaxSpeed = vehicle.vehicleBehavior.output.velocity;\n        }\n    }\n}\n",
        "description": "The SysML-V2 code defines a complex system model for electric vehicles, encompassing various components like Vehicle, Battery, Motor, and Tire, with detailed attributes, inputs, outputs, and state spaces, and includes requirements and analyses for range, efficiency, and maximum speed, facilitating comprehensive simulation and validation of EV performance."
    },
    {
        "code": "// State Space Representation cart example\n\npackage CartSample {\n    import StateSpaceRepresentation::*;\n    part def Cart {\n        attribute mass :> ISQ::mass;\n\n        attribute def CartInput :> Input {\n            attribute force :> ISQ::force;\n        }\n\n        attribute def CartOutput :> Output {\n            attribute velocity :> ISQ::speed;\n        }\n\n        attribute def CartState :> StateSpace {\n            attribute velocity :> ISQ::speed;\n        }\n\n        attribute def CartStateDerivative :> StateDerivative {\n            ref :>> stateSpace : CartState;\n            attribute accel :> ISQ::acceleration;\n        }\n    }\n\n    part def Pusher {\n        attribute def PusherOutput :> Output {\n            attribute force :> ISQ::force;\n        }\n    }\n\n    part context {\n        part cart : Cart {\n            action cartBehavior : ContinuousStateSpaceDynamics {\n                in input : CartInput;\n                out output : CartOutput;\n                :>> stateSpace : CartState;\n\n                calc :>> getDerivative { \n                \tin input: CartInput; \n                \tin stateSpace: CartState;\n                    CartStateDerivative(input.force / mass)\n                }\n                calc :>> getOutput {\n                \tin :>> stateSpace : CartState;\n                    CartOutput(stateSpace.velocity)\n                }\n            }\n        }\n        part pusher : Pusher {\n            attribute pusherForce :> ISQ::force;\n\n            action pusherBehavior : ContinuousStateSpaceDynamics {\n                in input;\n                out output : PusherOutput;\n                calc :>> getOutput {\n                    PusherOutput(pusherForce)\n                }\n            }\n        }\n\n        flow pusher.pusherBehavior.output.force to cart.cartBehavior.input.force;\n    }\n}\n",
        "description": "The SysML-V2 code defines a state space representation of a cart system, including its mass, input force, output velocity, and state derivatives, along with a pusher mechanism that provides the input force, and establishes a flow connection between the pusher's output force and the cart's input force."
    },
    {
        "code": "part def Camera {\n\timport PictureTaking::*;\n\t\n\tperform action takePicture[*] :> PictureTaking::takePicture;\n\t\n\tpart focusingSubsystem {\n\t\tperform takePicture.focus;\n\t}\n\t\n\tpart imagingSubsystem {\n\t\tperform takePicture.shoot;\n\t}\n\t\n}",
        "description": "The SysML-V2 code defines a Camera part with a PictureTaking import, which performs the takePicture action through its focusingSubsystem and imagingSubsystem parts, each responsible for focusing and shooting functionalities respectively."
    },
    {
        "code": "package PictureTaking {\n\tpart def Exposure;\n\t\n\taction def Focus { out xrsl: Exposure; }\n\taction def Shoot { in xsf: Exposure; }\t\n\t\t\n\taction takePicture {\t\t\n\t\taction focus: Focus[1];\n\t\tflow focus.xrsl to shoot.xsf;\n\t\taction shoot: Shoot[1];\n\t}\n}",
        "description": "The SysML-V2 code defines a system for taking a picture, including the parts and actions involved, such as focusing and shooting, with a flow of exposure data between these actions."
    },
    {
        "code": "// SysML v2 Interpretation of the SysML v1 Room Connection Example\npackage RoomModel { \n    package RoomDefinitionModelLibrary{\n        import Port_Definitions::*;\n        import Flow_Definitions::*;\n        package Part_Definitions{\n            // Rooms\n            part def Classroom {\n                port classEntry: EntryWay_to_Classroom;\n            }\n            part def Storageroom {\n                port storageEntry: EntryWay_to_Storageroom;\n            }\n            part def Hallway {\n                // conjugate ports with ~\n                port hallExit_to_Classroom: ~EntryWay_to_Classroom;\n                port hallExit_to_Storageroom: ~EntryWay_to_Storageroom;\n            }\n        }\n        package Port_Definitions{\n            port def EntryWay_to_Classroom {\n                //flow properties\n                in ref student:Student;\n                in ref teacher:Teacher;\n                in ref furniture:Furniture;\n                in ref air:Air;\n            }\n            port def EntryWay_to_Storageroom {\n                //flow properties\n                in ref furniture:  Furniture;\n                in ref air: Air;\n            }\n        }\n        package Flow_Definitions {\n                // Conveyed items between Hallway, Classroom, and Storageroom\n                part def Air;\n                part def Furniture;\n                part def Student;\n                part def Teacher;\n        }\n    }\n    package Room_Configuration{\n        // defining the parts and their interconnection in context \n        import RoomDefinitionModelLibrary::*;\n        import RoomDefinitionModelLibrary::Part_Definitions::*;\n        import RoomDefinitionModelLibrary::Port_Definitions::*;\n        import RoomDefinitionModelLibrary::Flow_Definitions::*;\n        part roomContext{\n            part c:Classroom;\n            part s:Storageroom;\n            part h:Hallway;\n            \n    \t\t//  Connectors and item flows between hallway and classroom\n            flow HallToClassroom_Air\n                from h.hallExit_to_Classroom.air\n                to c.classEntry.air;\n            flow HallToClassroom_Furniture\n                from h.hallExit_to_Classroom.furniture\n                to c.classEntry.furniture;\n            flow HallToClassroom_Student\n                from h.hallExit_to_Classroom.student\n                to c.classEntry.student;\n            flow HallToClassroom_Teacher\n                from h.hallExit_to_Classroom.teacher\n                to c.classEntry.teacher;\n            flow HallToStorageroom_Air\n                from h.hallExit_to_Storageroom.air\n                to s.storageEntry.air;\n            flow HallToStorageroom_Furniture\n                from h.hallExit_to_Storageroom.furniture\n                to s.storageEntry.furniture;\n        }\n    }\n}\n\n\n\n",
        "description": "The SysML-V2 code defines a model for connecting rooms (Classroom, Storageroom, and Hallway) through ports and flows, specifying the movement of items (Air, Furniture, Student, Teacher) between these rooms via a central context."
    },
    {
        "code": "package CauseAndEffectExample {\n\timport CauseAndEffect::*;\n\t\n\tpart def Causer1;\n\tpart def Causer2;\n\tpart def Effected1;\n\tpart def Effected2;\n\t\n\t#multicausation connection def MultiCauseEffect {\n\t\tend #cause cause1 : Causer1;\n\t\tend #cause cause2 : Causer2;\n\t\tend #effect effect1 : Effected1;\n\t\tend #effect effect2 : Effected2;\n\t}\n\t\n\tpart causer1 : Causer1;\n\tpart causer2 : Causer2;\n\tpart effected1 : Effected1;\n\tpart effected2 : Effected2;\n\t\n\t#multicausation connection : MultiCauseEffect connect\n\t\t( cause1 ::> causer1, cause2 ::> causer2,\n\t\t  effect1 ::> effected1, effect2 ::> effected2 );\n\t\t  \n\t#multicausation connect\n\t\t( cause1 ::> causer1, cause2 ::> causer2,\n\t\t  effect1 ::> effected1, effect2 ::> effected2 );\n\n    occurrence a;\n    item b;\n    part c;\n    action d;\n    \n\t#multicausation connection {\n\t\tend #cause ::> a;\n\t\tend #cause ::> b;\n\t\tend #effect ::> c;\n\t\tend #effect ::> d;\n\t}\n\t\n\t#cause causeA ::> a;\n\t#cause causeB ::> b;\n\t#effect effectC ::> c;\n\t#effect effectD ::> d;\n\t\n\t#multicausation connect ( causeA, causeB, effectC, effectD );\n\t\n\t#causation connect a to c;\n\t#causation connect b to d {\n\t\t@CausationMetadata {\n\t\t\tisNecessary = true;\n\t\t\tprobability = 0.1;\n\t\t}\n\t}\n}",
        "description": "The SysML-V2 code defines a system with multiple cause-effect relationships, connecting various parts and elements through multicausation and causation connections, and specifying metadata for certain relationships."
    },
    {
        "code": "package MedicalDeviceFailure {\n\timport CauseAndEffect::*;\n\t\n\tpart medicalDevice {\n\t\tpart battery {\n\t\t\tevent occurrence depleted;\n\t\t\tevent occurrence cannotBeCharged;\n\t\t}\n\t\t\n\t\tevent occurrence deviceFails;\n\t\t\n\t\tref patient {\n\t\t\tevent occurrence therapyDelayed;\n\t\t}\n\t\t\n\t\t#multicausation connection {\n\t\t\tend #cause ::> battery.depleted;\n\t\t\tend #cause ::> battery.cannotBeCharged;\n\t\t\tend #effect ::> deviceFails;\n\t\t}\n\t\t\n\t\t#causation connect deviceFails to patient.therapyDelayed;\n\t}\t\n\t\n}",
        "description": "The SysML-V2 code defines a medical device system with a battery component, specifying events for battery depletion and failure, and their causal relationships leading to device failure and delayed patient therapy."
    },
    {
        "code": "package 'Turbojet Stage Analysis' {\n\timport Quantities::ScalarQuantityValue;\n\timport MeasurementReferences::DimensionOneValue;\n\timport ISQ::*;\n\t\n\tpackage 'Thermodynamic Functions' {\n\t    calc def 'Ideal Gas Law' { in rho; in R_bar; in T;\n\t    \treturn p = rho * R_bar * T;\n\t    }\n\t    \n\t    calc def 'Reversible Adiabatic Compression Density' { in rho_1; in p_1; in p_2; in gamma;\n\t    \treturn rho_2 = rho_1 * (p_2 / p_1)^(1/gamma);\n\t    }\n\t    \n\t    calc def 'Reversible Adiabatic Compression Temperature' { in T_1; in p_1; in p_2; in gamma;\n\t    \treturn T_2 = T_1 * (p_2 / p_1)**((gamma - 1) / gamma);\n\t    }\n\t    \n\t    calc def 'Total Pressure' { in P_static; in rho; in V;\n\t    \t1/2 * rho * V^2 + P_static\n\t    }\n\t    \n\t    // Showing explicit parameter typing\n\t    calc def 'Total Temperature' { in T_static : TemperatureValue; in Cp : DimensionOneValue; in V : VolumeValue;\n\t    \treturn : TemperatureValue = 1/(2 * Cp) * V^2 + T_static;\n\t    }\n\t    \n\t    calc def 'Total Enthalpy' { in h_total; in h_static; in V;\n\t    \treturn H_total = 1/2 * V^2 + h_static;\n\t    }\n\t}\n\t\n\tpackage 'Thermodynamics Structure' {\n\t    part def 'Ideal Gas Parcel' {\n\t        comment\n\t            /*\n\t            The parcel is an infinitesimal volume used to analyze points in a flow\n\t            */\n\t        attribute 'Molar Mass';\n\t        attribute 'Density';\n\t        attribute 'Pressure';\n\t        attribute 'Temperature';\n\t        attribute 'Enthalpy';\n\t        attribute 'Specific Gas Constant';\n\t    }\n\t    \n\t    part def 'Moving Ideal Gas Parcel' specializes 'Ideal Gas Parcel' {\n\t        comment about 'Stagnation Pressure'\n\t            /*\n\t            Stagnation pressure is the pressure of the parcel if the kinetic energy defined by its\n\t            velocity in a given coordinate frame is converted to gas internal energy through deceleration\n\t            to a velocity that matches the current frame.\n\t            */\n\t        attribute 'Stagnation Pressure';\n\t        attribute 'Stagnation Temperature';\n\t        attribute 'Stagnation Enthalpy';\n\t        \n\t        comment about 'Static Pressure'\n\t            /*\n\t            Static pressure is the pressure of the parcel as it moves\n\t            */\n\t        attribute 'Static Pressure' redefines 'Ideal Gas Parcel'::'Pressure';\n\t        attribute 'Static Temperature' redefines 'Ideal Gas Parcel'::'Temperature';\n\t        attribute 'Static Enthalpy' redefines 'Ideal Gas Parcel'::'Enthalpy';\n\t    }\n\t    \n\t    action def 'Thermodynamic Process'; // need start and end shots to show beginning and end attributes\n\t    \n\t    action def 'Adiabatic Process' specializes 'Thermodynamic Process' {\n\t        /*\n\t        Thermodynamic process typically have their states defined at beginning and end\n\t        of the process (since these starts are path-independent)\n\t        */\n\t        action 'Stage 1' :>> start;\n\t        action 'Stage 2' :>> done;\n\t    }\n\t    \n\t    action def 'Reversible Adiabatic Process' specializes 'Adiabatic Process';\n\t}\n\t\n\tpackage 'Low-Pressure Compressor Analysis' {\n\t    \n\t    part 'Analysis Context' {\n\t        import 'Thermodynamic Functions'::*;\n\t        \n\t        part 'Inlet Gas' : 'Thermodynamics Structure'::'Moving Ideal Gas Parcel' {\n\t        \t// Explicit binding notation\n\t        \tcalc 'Solve for Pressure1' : 'Ideal Gas Law';\n\t        \tbind 'Density' = 'Solve for Pressure1'.rho;\n\t        \tbind 'Specific Gas Constant' = 'Solve for Pressure1'.R_bar;\n\t        \tbind 'Static Temperature' = 'Solve for Pressure1'.T;\n\t        \tbind 'Static Pressure' = 'Solve for Pressure1'.p;\t        \t\n\t        \t\n\t        \t// Shorthand parameter binding notation\n\t            calc 'Solve for Pressure2' : 'Ideal Gas Law' {\n\t                in rho = 'Density';\n\t                in R_bar = 'Specific Gas Constant';\n\t                in T = 'Static Temperature';\n\t\t\t\t}\t\t\t\t\n\t\t\t\t            \n\t            // Invocation expression notation\n\t            attribute :>> 'Static Pressure' = 'Ideal Gas Law'('Density', 'Specific Gas Constant', 'Static Temperature');\n\n\t            // Equation as a constraint (note \"==\")\n\t            constraint { 'Static Pressure' == 'Ideal Gas Law'('Density', 'Specific Gas Constant', 'Static Temperature') }\n\t        }\n\t    }\n\t}\t\n\t\n}",
        "description": "The SysML-V2 code defines a comprehensive model for analyzing turbojet stages, including thermodynamic functions, structures, and specific analyses like low-pressure compressor stages, utilizing calculations, part definitions, and action definitions to simulate and compute various gas properties and processes."
    },
    {
        "code": "package Dynamics {\n\timport ScalarValues::Real;\n\timport ISQ::*;\n\t\n\t// Function definitions\n\t\n\tcalc def Power {\n\t\tin whlpwr : PowerValue; in Cd : Real; in Cf : Real; in tm : MassValue; in v : SpeedValue;\n\t\treturn tp : PowerValue = whlpwr - Cd * v - Cf * tm * v;\n\t}\n\t\n\tcalc def Acceleration { in dt : TimeValue; in tm : MassValue; in tp: PowerValue; \n\t\treturn a : AccelerationValue = tp * dt * tp;\n\t}\n\t\n\tcalc def Velocity { in dt : TimeValue; in v0 : SpeedValue; in a : AccelerationValue;\n\t\treturn v : SpeedValue = v0 + a * dt;\n\t}\n \t\n\tcalc def Position { in dt : TimeValue; in x0 : LengthValue; in v : SpeedValue; \n\t\treturn x : LengthValue = x0 + v * dt;\n\t}\n\n\t// Analysis action def\n\t\n\taction def StraightLineVehicleDynamics {\n\t\t\n\t\tin attribute dt : TimeValue;\n\t\tin attribute whlpwr : PowerValue;\n\t\tin attribute Cd : Real;\n\t\tin attribute Cf: Real;\n\t\tin attribute tm : MassValue;\n\t\tin attribute v_in : SpeedValue;\n\t\tin attribute x_in : LengthValue;\n\t\t\n\t\tout attribute a_out : AccelerationValue;\n\t\tout attribute v_out : SpeedValue;\n\t\tout attribute x_out : LengthValue;\n\t\t\t\n\t\tassert constraint {\n\t\t\tattribute tp : PowerValue;\n\t\t\t\n\t\t\ttp == Power(whlpwr, Cd, Cf, tm, v_in) &\n\t\t\ta_out == Acceleration(dt, tm, tp) &\n\t\t\tv_out == Velocity(dt, v_in, a_out) &\n\t\t\tx_out == Position(dt, x_in, v_in)\n\t\t}\n\t}\n\t\n\n\t// Analysis actions\n\t\n\taction dyn1 : StraightLineVehicleDynamics {\n        in attribute dt : TimeValue;\n        in attribute whlpwr : PowerValue;\n        in attribute Cd : Real;\n        in attribute Cf: Real;\n        in attribute tm : MassValue;\n        in attribute v_in : SpeedValue;\n        in attribute x_in : LengthValue;\n\n\t\tattribute tp : PowerValue = Power(whlpwr, Cd, Cf, tm, v_in);\n\t\t\n\t\tout attribute :>> a_out : AccelerationValue = Acceleration(dt, tm, tp);\n\t\tout attribute :>> v_out : SpeedValue = Velocity(dt, v_in, a_out);\n\t\tout attribute :>> x_out : LengthValue = Position(dt, x_in, v_in);\n\t}\t\n\t\n\taction dyn2 : StraightLineVehicleDynamics {\n\t\tcalc acc : Acceleration {\n\t\t\tin dt = dyn2::dt;\n\t\t\tin tm = dyn2::tm;\n\t\t\tin tp = Power(whlpwr, Cd, Cf, tm, v_in);\n\t\t}\n\t\tbind a_out = acc.a;\n\t\t\n\t\tcalc vel : Velocity {\n\t\t\tin dt = dyn2::dt;\n\t\t\tin v0 = dyn2::v_in; \n\t\t\tin a = acc.a;\n\t\t}\n\t\tbind v_out = vel.v;\n\t\t\n\t\tcalc pos : Position {\n\t\t\tin dt = dyn2::dt;\n\t\t\tin x0 = dyn2::x_in;\n\t\t\tin v0 = vel.v;\n\t\t}\n\t\tbind x_out = pos.x;\n\t}\n}",
        "description": "The SysML-V2 code defines a system for simulating straight-line vehicle dynamics, including functions to calculate power, acceleration, velocity, and position, and actions to analyze and assert constraints on these calculations."
    },
    {
        "code": "package 'Vehicle Analysis Demo' {\n\tpackage VehicleQuantities {\n\t    import ScalarValues::*;\n\t    import Quantities::*;\n\t    import MeasurementReferences::*;\n\t    import ISQ::*;\n\t    import USCustomaryUnits::*;\n\t    \n\t    attribute def DistancePerVolumeUnit :> DerivedUnit {\n\t    \tprivate attribute distancePF: QuantityPowerFactor[1] { :>> quantity = isq.L; :>> exponent = 1; }\n\t        private attribute volumePF: QuantityPowerFactor[1] { :>> quantity = isq.L; :>> exponent = -3; }\n\t        attribute :>> quantityDimension { :>> quantityPowerFactors = (distancePF, volumePF); }\n\t    }\n\n\t    attribute def DistancePerVolumeValue :> ScalarQuantityValue {\n\t        :>> num : Real;\n\t        :>> mRef : DistancePerVolumeUnit;\n\t    }\n\t    \n\t    attribute gallon : VolumeUnit = 231.0 * 'in' ** 3;\n\t    attribute mpg : DistancePerVolumeUnit = 'mi' / gallon;\n\t}\n\t\n\tpackage VehicleModel {\n\t    import VehicleQuantities::*;\n\t    \n\t    item def Fuel;\n\t        \n\t    port def FuelPort {\n\t        out item fuel: Fuel;\n\t    }\n\t    \n\t    part def FuelTank {\n\t        attribute volumeMax : VolumeValue;\n\t        attribute fuelVolume : VolumeValue;\n\t        attribute fuelLevel : Real = fuelVolume / volumeMax;\n\t        \n\t        port fuelInPort : ~FuelPort;\n\t        port fuelOutPort : FuelPort;\n\t    }\n\t    \n\t    part def Wheel {\n\t        attribute diameter : LengthValue;\n\t    }\n\t\n\t    part def Vehicle {\n\t        attribute mass : MassValue;\n\t        attribute cargoMass : MassValue;\n\t        \n\t        attribute wheelDiameter : LengthValue;\n\t        attribute driveTrainEfficiency : Real;\n\t        \n\t        attribute fuelEconomy_city : DistancePerVolumeValue;\n\t        attribute fuelEconomy_highway : DistancePerVolumeValue;\n\t\n\t        port fuelInPort : ~FuelPort;\n\t    }\n\t    \n\t    part vehicle_c1 : Vehicle {\n\t        port :>> fuelInPort {\n\t            in item :>> fuel; \n\t        }\n\t\n\t        part fuelTank : FuelTank {\n\t            port :>> fuelInPort {\n\t                in item :>> fuel;\n\t            }\n\t        }\n\t\n\t        bind fuelInPort.fuel = fuelTank.fuelInPort.fuel;\n\t\n\t        part wheel : Wheel[4] {\n\t            :>> diameter = wheelDiameter;\n\t        }\n\t    }\n\t}\n\t\n\tpackage FuelEconomyRequirementsModel {\n\t    import VehicleQuantities::*;\n\t\n\t    requirement def FuelEconomyRequirement {\n\t        attribute actualFuelEconomy : DistancePerVolumeValue;\n\t        attribute requiredFuelEconomy : DistancePerVolumeValue;\n\t\n\t        require constraint { actualFuelEconomy >= requiredFuelEconomy }\n\t    }\n\t\n\t    requirement cityFuelEconomyRequirement : FuelEconomyRequirement {\n\t        :>> requiredFuelEconomy = 25 [mpg];\n\t    }\n\t\n\t    requirement highwayFuelEconomyRequirement : FuelEconomyRequirement {\n\t        :>> requiredFuelEconomy = 30 [mpg];\n\t    }\n\t}\n\t\n\tpackage DynamicsModel {\n\t    import VehicleQuantities::*;\n\t    \n\t    calc def Acceleration { in p : PowerValue; in m : MassValue; in v : SpeedValue;\n\t    \treturn : AccelerationValue = p / (m * v);\n\t    }\n\t    \n\t    calc def Velocity { in v0 : SpeedValue; in a : AccelerationValue; in dt : TimeValue;\n\t    \treturn : SpeedValue = v0 + a * dt;\n\t\t}\n\t\t    \n\t    calc def Position { in x0 : LengthValue; in v : SpeedValue; in dt : TimeValue;\n\t    \treturn : LengthValue = x0 + v * dt;\n\t    }\n\t    \n\t    constraint def StraightLineDynamicsEquations {\n\t        in p : PowerValue;\n\t        in m : MassValue;\n\t        in dt : TimeValue;\n\t        in x_i : LengthValue;\n\t        in v_i : SpeedValue;\n\t        in x_f : LengthValue;\n\t        in v_f : SpeedValue;\n\t        in a : AccelerationValue;\n\t    \n\t        attribute v_avg : SpeedValue = (v_i + v_f)/2;\n\t\n\t        a == Acceleration(p, m, v_avg) &\n\t        v_f == Velocity(v_i, a, dt) &\n\t        x_f == Position(x_i, v_avg, dt)\n\t    }\n\t    \n\t    action def StraightLineDynamics {\n\t        in power : PowerValue;\n\t        in mass : MassValue;\n\t        in delta_t : TimeValue;\n\t        in x_in : LengthValue;\n\t        in v_in : SpeedValue;\n\t        out x_out : LengthValue;\n\t        out v_out : SpeedValue;\n\t        out a_out : AccelerationValue;\n\t    \n\t        assert constraint dynamics : StraightLineDynamicsEquations {\n\t            in p = power;\n\t            in m = mass;\n\t            in dt = delta_t;\n\t            in x_i = x_in;\n\t            in v_i = v_in;\n\t            in x_f = x_out;\n\t            in v_f = v_out;\n\t            in a = a_out;\n\t        }\n\t    }\n\t}\n\t\n\tpackage FuelEconomyAnalysisModel {\n\t    import VehicleModel::*;\n\t    import FuelEconomyRequirementsModel::*;\n\t    import DynamicsModel::*;\n\t    import SequenceFunctions::size;\n\t    import SampledFunctions::SampledFunction;\n\t    import SampledFunctions::SamplePair;\n\t    import ControlFunctions::forAll;\n\t\n\t\tattribute def ScenarioState {\n\t\t\tposition : LengthValue;\n\t\t\tvelocity : SpeedValue;\n\t\t}\n\t\t\n\t\tattribute def NominalScenario :> SampledFunction {\n\t\t\tattribute def TimeStateRecord :> SamplePair {\n\t\t\t\tt : TimeValue :>> domainValue;\n\t\t\t\ts : ScenarioState :>> rangeValue;\n\t\t\t}\n\t\t\t:>> samples : TimeStateRecord;\n\t\t\tn : Natural = size(samples);\n\t\t}\n\t\t\n\t\tanalysis def FuelEconomyAnalysis { \n\t\t\tsubject vehicle: Vehicle;\n\t\t\tin attribute scenario : NominalScenario;\n\t\t\tin requirement fuelEconomyRequirement : FuelEconomyRequirement;\n\t\t\treturn calculatedFuelEconomy : DistancePerVolumeValue;\n\t\t\t\n\t\t\tobjective fuelEconomyAnalysisObjective {\n\t\t\t\tdoc \n\t\t\t\t/*\n\t\t\t\t * The objective of this analysis is to determine whether the\n\t\t\t\t * current vehicle design configuration can satisfy the fuel\n\t\t\t\t * economy requirement.\n\t\t\t\t */\n\t\t\t\t\n\t\t\t\tassume constraint {\n\t\t\t\t\tvehicle.wheelDiameter == 33 ['in'] &\n\t\t\t\t\tvehicle.driveTrainEfficiency == 0.4\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\trequire fuelEconomyRequirement { \n\t\t\t\t\t:>> actualFuelEconomy = calculatedFuelEconomy;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\taction dynamicsAnalysis {\n\t\t\t\tin sc: NominalScenario;\n\t\t\t\tout power : PowerValue[*];\n\t\t\t\tout acceleration : AccelerationValue[*];\n\t\t\t\t/*\n\t\t\t\t * Solve for the required engine power as a function of time\n\t\t\t\t * to support the scenarios.\n\t\t\t\t */\n\t\t\t\tassert constraint straightLineDynamics {\n\t\t\t\t\t(1..sc.n-1)->forAll {in i: Integer;\n\t\t\t\t\t\tprivate thisSample : NominalScenario::TimeStateRecord = \n\t\t\t\t\t\t\tsc.samples#(i);\n\t\t\t\t\t\tprivate nextSample : NominalScenario::TimeStateRecord = \n\t\t\t\t\t\t\tsc.samples#(i+1);\n\t\t\t\t\t\tStraightLineDynamicsEquations (\n\t\t\t\t\t\t\tp = power#(i),\n\t\t\t\t\t\t\tm = vehicle.mass,\n\t\t\t\t\t\t\tdt = nextSample.t - thisSample.t,\n\t\t\t\t\t\t\tx_i = thisSample.s.position,\n\t\t\t\t\t\t\tv_i = thisSample.s.velocity,\n\t\t\t\t\t\t\tx_f = nextSample.s.position,\n\t\t\t\t\t\t\tv_f = nextSample.s.velocity,\n\t\t\t\t\t\t\ta = acceleration#(i)                    \n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t    action fuelConsumptionAnalysis {\n\t\t        in power : PowerValue[*] = dynamicsAnalysis.power;\n\t\t        in acceleration : AccelerationValue[*] = dynamicsAnalysis.acceleration;\n\t\t        out fuelEconomy : DistancePerVolumeValue = calculatedFuelEconomy;\n\t\t        /*\n\t\t         * Solve the engine equations to determine how much fuel is\n\t\t         * consumed. The engine RPM is a function of the speed of the\n\t\t         * vehicle and the gear state.\n\t\t         */\n\t        }\n\t    }\n\t}\n\n\t\n\tpart vehicleFuelEconomyAnalysisContext {\n\t    import FuelEconomyAnalysisModel::*;\n\t\n\t    requirement vehicleFuelEconomyRequirementsGroup {\n\t        import FuelEconomyRequirementsModel::*;\n\t        \n\t        subject vehicle : Vehicle;\n\t\n\t        requirement vehicleFuelEconomyRequirement_city :> cityFuelEconomyRequirement {\n\t            doc /* The vehicle shall provide a fuel economy that is greater than or equal to\n\t             * 25 miles per gallon for the nominal city driving scenarios.\n\t             */\n\t\n\t            :>> actualFuelEconomy = vehicle.fuelEconomy_city;\n\t\n\t            assume constraint { vehicle.cargoMass == 1000 [lb] }\n\t        }\n\t\n\t        requirement vehicleFuelEconomyRequirement_highway :> highwayFuelEconomyRequirement {\n\t            doc /* The vehicle shall provide a fuel economy that is greater than or equal to\n\t             * 30 miles per gallon for the nominal highway driving scenarios.\n\t             */\n\t\n\t            :>> actualFuelEconomy = vehicle.fuelEconomy_highway;\n\t\n\t            assume constraint { vehicle.cargoMass == 1000 [lb] }\n\t        }\n\t\n\t    }\n\t    \n\t    attribute cityScenario : NominalScenario;\n\t    attribute highwayScenario : NominalScenario;\n\t\n\t    analysis cityFuelEconomyAnalysis : FuelEconomyAnalysis {\n\t        subject vehicle = vehicle_c1;\n\t        in attribute scenario = cityScenario;\n\t        in requirement fuelEconomyRequirement = cityFuelEconomyRequirement;\n\t    }\n\t\n\t    analysis highwayFuelEconomyAnalysis : FuelEconomyAnalysis {\n\t        subject vehicle = vehicle_c1;\n\t        in attribute scenario = highwayScenario;\n\t        in requirement fuelEconomyRequirement = highwayFuelEconomyRequirement;\n\t    }\n\t\n\t    part vehicle_c1_analysized :> vehicle_c1 {\n\t        attribute :>> fuelEconomy_city = cityFuelEconomyAnalysis.calculatedFuelEconomy;\n\t        attribute :>> fuelEconomy_highway = highwayFuelEconomyAnalysis.calculatedFuelEconomy;\n\t    }\n\t\n\t    satisfy vehicleFuelEconomyRequirementsGroup by vehicle_c1_analysized;\n\t}\n}",
        "description": "The SysML-V2 code defines a comprehensive vehicle analysis system, encompassing units and quantities, vehicle models, fuel economy requirements, dynamics calculations, and analysis models to determine and verify fuel economy performance against specified requirements, utilizing various mathematical and logical constraints and interactions between vehicle components and scenarios."
    },
    {
        "code": "package AnalysisAnnotation {\n\timport ScalarValues::Real;\n\timport AnalysisTooling::*;\n\timport ISQ::*;\n\t\n\taction def ComputeDynamics {\n\t\tmetadata ToolExecution {\n\t\t\ttoolName = \"ModelCenter\";\n\t\t\turi = \"aserv://localhost/Vehicle/Equation1\";\n\t\t}\n\t\t\t\n\t\tin dt : TimeValue             { @ToolVariable { name = \"deltaT\"; } }\n\t\tin whlpwr : PowerValue        { @ToolVariable { name = \"power\"; } }\n\t\tin Cd : Real                  { @ToolVariable { name = \"C_D\"; } }\n\t\tin Cf: Real                   { @ToolVariable { name = \"C_F\"; } }\n\t\tin tm : MassValue             { @ToolVariable { name = \"mass\"; } }\n\t\tin v_in : SpeedValue          { @ToolVariable { name = \"v0\"; } }\n\t\tin x_in : LengthValue         { @ToolVariable { name = \"x0\"; } }\n\t\t\n\t\tout a_out : AccelerationValue { @ToolVariable { name = \"a\"; } }\n\t\tout v_out : SpeedValue        { @ToolVariable { name = \"v\"; } }\n\t\tout x_out : LengthValue       { @ToolVariable { name = \"x\"; } }\n\t\t\t\n\t}\n\n}",
        "description": "The SysML-V2 code defines a computational action named `ComputeDynamics` within the `AnalysisAnnotation` package, which utilizes the \"ModelCenter\" tool to calculate dynamics based on input parameters like time step, power, drag coefficient, friction coefficient, mass, initial velocity, and initial position, and outputs resulting acceleration, velocity, and position."
    },
    {
        "code": "package AnalysisIndividualExample {\n\tpackage VehicleQuantities {\n\t    import ScalarValues::*;\n\t    import Quantities::*;\n\t    import MeasurementReferences::*;\n\t    import ISQ::*;\n\t    import USCustomaryUnits::*;\n\t    \n\t    attribute def DistancePerVolumeUnit :> DerivedUnit {\n\t    \tprivate attribute distancePF: QuantityPowerFactor[1] { :>> quantity = isq.L; :>> exponent = 1; }\n\t        private attribute volumePF: QuantityPowerFactor[1] { :>> quantity = isq.L; :>> exponent = -3; }\n\t        attribute :>> quantityDimension { :>> quantityPowerFactors = (distancePF, volumePF); }\n\t    }\n\n\t    attribute def DistancePerVolumeValue :> ScalarQuantityValue {\n\t        :>> num : Real;\n\t        :>> mRef : DistancePerVolumeUnit;\n\t    }\n\t    \n\t    attribute gallon : VolumeUnit = 231.0 * 'in' ** 3;\n\t    attribute mpg : DistancePerVolumeUnit = 'mi' / gallon;\n\t    attribute hp : PowerUnit = 745.7[SI::W];\n\t}\n\t\n\tpackage VehicleModel {\n\t    import VehicleQuantities::*;\n\t    \n\t    part def Vehicle {\n\t    \tattribute power :> ISQ::power;\n\t    }\n\t    \n\t    part def Engine {\n\t    \tattribute peakPower :> ISQ::power;\n\t    \tattribute fuelEfficiency : Real;\n\t    }\n\t    \n\t    part vehicle_c1 : Vehicle {\n\t    \tattribute :>> power = engine.peakPower;\n\t    \tpart engine : Engine[1];\n\t    }\n\t}\n\t\n\tpackage FuelEconomyAnalysisModel {\n\t    import VehicleModel::*;\n\t    import SequenceFunctions::size;\n\t    import SampledFunctions::SampledFunction;\n\t    import SampledFunctions::SamplePair;\n\t    import ControlFunctions::forAll;\n\t    \n\t    action def FuelConsumption {\n\t\t\tin power : PowerValue[*];\n\t\t\tout fuelEconomy : DistancePerVolumeValue;\n\t\t}\n\t\t\n\t\tanalysis def FuelEconomyAnalysis {\n\t\t\tsubject vehicle: Vehicle;\n\n\t\t    action fuelConsumption : FuelConsumption {\n\t\t    \tin power = vehicle.power;\n\t\t        out fuelEconomy : DistancePerVolumeValue;\n\t        }\n\t        \n\t\t\treturn calculatedFuelEconomy : DistancePerVolumeValue =\n\t\t\t\tfuelConsumption.fuelEconomy;\t        \n\t    }\n\t}\n\t\n\tpackage IndividualAnalysisModel {\n\t\timport VehicleModel::*;\n\t\timport FuelEconomyAnalysisModel::*;\n\t\t\n\t\tindividual part def Vehicle_1 :> Vehicle;\n\t\tindividual part def Engine_1 :> Engine;\n\t\t\n\t\tindividual analysis def FuelEconomyAnalysis_1 :> FuelEconomyAnalysis;\n\t\tindividual action def FuelConsumption_1 :> FuelConsumption;\n\t\t\n\t\tindividual analysis fuelEconomyAnalysis_1 : FuelEconomyAnalysis_1 {\n\t\t\tsubject vehicle : Vehicle_1 :> vehicle_c1 {\n\t\t\t\tindividual part :>> engine : Engine_1 {\n\t\t\t\t\tattribute :>> peakPower = 200[hp];\n\t\t\t\t\tattribute :>> fuelEfficiency = 0.4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tindividual action :>> fuelConsumption : FuelEconomyAnalysis_1 {\n\t\t\t\tsnapshot :>> done :> fuelConsumption {\n\t\t\t\t\tout :>> fuelEconomy = 35[mph];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}",
        "description": "The SysML-V2 code defines a system for analyzing vehicle fuel economy, including the definition of quantities like distance per volume and power, the modeling of vehicle and engine parts, and the execution of an analysis to calculate fuel efficiency based on input power and output fuel economy values."
    },
    {
        "code": "package JohnIndividualExample {\n\t\n\titem def Person {\n\t\tdoc\t\n\t\t/*\n\t\t * This is the definition of the class of persons, each of whom has an age.\n\t\t */\n\n\t\tattribute age : ScalarValues::Natural;\t\t\n\t\t\n\t\ttimeslice asPresident : Person [0..*] {\n\t\t\tdoc\n\t\t\t/*\n\t\t\t * These are the periods during which a Person is president.\n\t\t\t */\n\t\t}\n\t}\n\t\n\tindividual item def John :> Person {\n\t\tdoc\n\t\t/*\n\t\t * This the definition of the individual Person who is John.\n\t\t * There is at most one such person.\n\t\t */\n\t}\n\t\n\titem def Country {\n\t\tdoc\n\t\t/*\n\t\t * This is the definition of the class of countries, each of which may have \n\t\t * at most one president (at any point in time).\n\t\t */\n\t\tref presidentOfCountry[0..1] : Person :> presidentOfCountry.asPresident;\n\t}\n\t\n\tindividual item def UnitedStates :> Country {\n\t\tdoc\n\t\t/*\n\t\t * This is the definition of the individual country that is the\n\t\t * United States. It contains a single instance. The United States\n\t\t * always has a president who must be at least 35 years old.\n\t\t */\n\t\t \n\t\tref presidentOfUS[1] :>> presidentOfCountry {\n\t   \t\tassert constraint { age >= 35 } \n\t  \t}\n\t}\n\t\n\ttimeslice item UnitedStatesWithJohnAsPresident[*] : UnitedStates {\n\t\tdoc\n\t\t/*\n\t\t * These are the time slices of the United States during\n\t\t * which John is president of the United States.\n\t\t */\n\t\tref :>> presidentOfUS : John;\n\t}\n}",
        "description": "The SysML-V2 code defines a model where individuals like \"John\" can be instances of the class \"Person\" with attributes like \"age,\" and relationships such as \"presidentOfCountry\" are established between \"Person\" and \"Country\" instances like \"UnitedStates,\" with constraints ensuring the president meets specific criteria."
    },
    {
        "code": "package RiskMetadataExample {\n\timport RiskMetadata::*;\n\timport RiskLevelEnum::*;\n\t\n    part engine4cyl{\n        @Risk {\n            totalRisk = high;\n            technicalRisk = medium;\n            scheduleRisk = medium;\n        }\n        @Risk {\n        \ttotalRisk { \n        \t\tprobability = 0.3;\n        \t\timpact = 0.7;\n        \t}        \t\n        }\n    }\n        \n}",
        "description": "The SysML-V2 code snippet defines a part named \"engine4cyl\" with associated risk metadata, including total, technical, and schedule risks, along with detailed probability and impact values for the total risk."
    },
    {
        "code": "package VerificationMetadataExample {\n\timport VerificationCases::*;\n\timport VerificationMethodKind::*;\n\t\n    verification def MassTest;\n    verification massTests:MassTest {\n        @VerificationMethod{ kind = (test,demo); }\n        objective {\n        }\n        action weighVehicle {\n        \t@VerificationMethod{ kind = analyze; }\n        }\n    }\n\t\n}",
        "description": "The SysML-V2 code defines a verification package with a MassTest case, specifying its kind as test and demo, and includes an action to weigh the vehicle with an analyze method."
    },
    {
        "code": "package RationaleMetadataExample {\n\timport ModelingMetadata::Rationale;\n\t\n    /* Example: the following provides the rationale for selecting the engine4cyl based on a trade study analysis. \n    The rationale could be contained in the vehicle configuration with the selected engine */\n    \n    part engine;\n    part engine4cyl :> engine;\n    part engine6cyl :> engine;\n    \n    metadata engineSelectionRationale : Rationale about engine4cyl {\n    \ttext = \"This rationale for selecting the engine4cyl refers to the engineTradeOffAnalysis.\";\n    \texplanation = engineTradeOffAnalysis;\n    }\n    \n    import TradeStudies::*;\n    analysis engineTradeOffAnalysis:TradeStudy{\n        subject alternatives :> engine [2] = (engine4cyl, engine6cyl);\n\n        /* ... */\n        \n        return selectedEngine :> engine;\n     }\n}",
        "description": "The SysML-V2 code in the `RationaleMetadataExample` package demonstrates the use of metadata to attach a rationale to a selected part (`engine4cyl`), referencing an analysis (`engineTradeOffAnalysis`) that compares it with another part (`engine6cyl`) to justify the selection."
    },
    {
        "code": "package RequirementMetadataExample {\n\timport Metaobjects::SemanticMetadata;\n\timport ModelingMetadata::*;\n\timport RiskMetadata::*;\n\timport RiskLevelEnum::*;\n\t\n\trequirement def Goal;\n\trequirement goals : Goal[*] nonunique;\n\tmetadata def goal :> SemanticMetadata {\n\t    :>> baseType = goals meta SysML::RequirementUsage;\n\t}\n\n    requirement <'1'> vehicleMassRequirement {\n        doc /* The total mass of a vehicle shall be less than or equal to the required mass. */\n \n        @StatusInfo {\n            status = StatusKind::tbd;\n            risk {\n\t\t    \ttotalRisk = high;\n\t\t    \ttechnicalRisk = medium;\n\t\t    \tscheduleRisk = low;\n\t\t    \tcostRisk = medium;\n\t\t    }            \n\t\t    originator = \"Bob\";\n            owner = \"Mary\";\n        }\n    }\n    \n    #goal requirement deliverPayload {\n    \tassume #goal constraint payloadMassLimit;\n    \trequire #goal vehicleMassRequirement;\n    }\n    \n}",
        "description": "The SysML-V2 code defines a system requirement with metadata including status, risk levels, and ownership, and links it to related goals and constraints within a structured model."
    },
    {
        "code": "package IssueMetadataExample {\n\timport ModelingMetadata::Issue;\n\t\n    //Example: the following identifies an issue with the interface\n    \n    metadata InterfaceCompatibilityIssue : Issue about engineToTransmissionInterface {\n    \ttext = \"This issue is about the interface compatability between the engine and transmission.\" +\n               \"The interface def includes an end defined by a ClutchPort.\" +\n               \"However, the interface usage connects the transmission port that is defined by ~DrivePwrPort.\" +\n               \"This should have surfaced a compatibility issue, since the interface is not really compatible with its definition\";\n    }\n    \n    interface def EngineToTransmissionInterface{\n        end p1:DrivePwrPort;\n        end p2:ClutchPort;\n    }\n    port def DrivePwrPort;\n    port def ClutchPort;\n    \n    part engine{\n        port drivePwrPort:DrivePwrPort;\n    }\n    part transmission{\n        port clutchPort:~DrivePwrPort;\n    }\n\n    interface engineToTransmissionInterface:EngineToTransmissionInterface\n        connect engine.drivePwrPort to transmission.clutchPort;       \n\n}",
        "description": "The SysML-V2 code defines an issue metadata example that identifies a compatibility issue between an engine and transmission interface, highlighting a mismatch between the interface definition and its usage."
    },
    {
        "code": "package HSUVRequirements {\n\timport Requirements::*;\n\t\n\trequirement <'UR1.1'> Load: FunctionalRequirementCheck {\n\t\t// The following requirements are composite sub-requirements.\n\t\trequirement Passengers;\n\t\trequirement FuelCapacity;\n\t\trequirement Cargo;\n\t}\n\t\n\trequirement <'UR1.2'> EcoFriendliness: PerformanceRequirementCheck {\n\t\trequirement <'URI1.2.1'> Emissions: PerformanceRequirementCheck {\n\t\t\t/* The car shall meet 2010 Kyoto Accord emissions standards. */\n\t\t}\n\t}\n\t\n\trequirement <'UR1.3'> Performance: PerformanceRequirementCheck {\n\t\trequirement Acceleration;\n\t\trequirement <'UR1.3.1'> FuelEconomy: PerformanceRequirementCheck {\n\t\t\t/* User shall obtain fuel economy better than that provided by\n\t\t\t * 95% of cars built in 2004.\n\t\t\t */\n\t\t}\n\t\trequirement Braking;\n\t\trequirement Range;\n\t\trequirement Power;\n\t}\n\t\n\trequirement <'UR1.4'> Ergonomics;\n\t\n\t// Syntactically, should this be explicitly marked as a \"group\"?\n\trequirement HybridSUVSpec {\t\t\n\t\t// The following requirements are required by reference.\n\t\trequire Load;\n\t\trequire EcoFriendliness;\n\t\trequire Performance;\n\t\trequire Ergonomics;\n\t}\n}",
        "description": "The SysML-V2 code defines a structured hierarchy of requirements for a hybrid SUV, categorizing them into functional, performance, and ergonomic aspects, and ensuring they are referenced collectively in a main specification group."
    },
    {
        "code": "package RequirementDerivationExample {\n\timport RequirementDerivation::*;\n\t\n\trequirement def Req1;\n\t\n\trequirement def Req1_1;\n\trequirement def Req1_2;\n\t\n\t#derivation connection def Req1_Derivation {\n\t\tend #original r1 : Req1;\n\t\tend #derive r1_1 : Req1_1;\n\t\tend #derive r1_2 : Req1_2;\n\t}\n\t\n\tpart def System;\n\tpart def Subsystem1;\n\tpart def Subsystem2;\n\t\n\tpart system : System {\n\t\tpart sub1 : Subsystem1;\n\t\tpart sub2 : Subsystem2;\n\t}\n\t\n\tpart satisfactionContext {\n\t\tref :>> system;\n\t\t\n\t\tsatisfy requirement req1 : Req1 by system;\n\t\tsatisfy requirement req1_1 : Req1_1 by system.sub1;\n\t\tsatisfy requirement req1_2 : Req1_2 by system.sub2;\n\t\t\n\t\t#derivation connection : Req1_Derivation {\n\t\t\tend r1 ::> req1;\n\t\t\tend r1_1 ::> req1_1;\n\t\t\tend r1_2 ::> req1_1;\n\t\t}\n\t\t\n\t}\n\t\n}",
        "description": "The SysML-V2 code defines a system with requirements, their derivations, and satisfaction contexts, illustrating how higher-level requirements are broken down into sub-requirements and satisfied by different subsystems."
    },
    {
        "code": "package VehicleRequirementDerivation {\n\timport RequirementDerivation::*;\n\t\n\tpart vehicle {\n\t\tattribute mass :> ISQ::mass;\n\t\t\n\t\tpart chassis {\n\t\t\tattribute mass :> ISQ::mass;\n\t\t}\n\t\t\n\t\tpart engine {\n\t\t\tattribute mass :> ISQ::mass;\n\t\t}\n\t}\n\t\n\trequirement def MassRequirement {\n\t\tsubject mass :> ISQ::mass;\n\t\tattribute massLimit :> ISQ::mass;\n\t\trequire constraint { mass <= massLimit }\n\t}\n\t\n\trequirement vehicleMassRequirement : MassRequirement {\n\t\tsubject :>> mass = vehicle.mass;\n\t}\n\t\n\trequirement chassisMassRequirement : MassRequirement {\n\t\tsubject :>> mass = vehicle.chassis.mass;\n\t}\n\t\n\trequirement engineMassRequirement : MassRequirement {\n\t\tsubject :>> mass = vehicle.engine.mass;\n\t}\n\t\n\t#derivation connection {\n\t\tend #original ::> vehicleMassRequirement;\n\t\tend #derive ::> chassisMassRequirement;\n\t\tend #derive ::> engineMassRequirement;\n\t}\n\t\n}",
        "description": "The SysML-V2 code defines a vehicle system with parts (chassis and engine), assigns mass attributes to each part, and establishes mass requirements for the vehicle, chassis, and engine, ensuring that their masses do not exceed specified limits, with the vehicle's mass requirement being derived from the chassis and engine mass requirements."
    },
    {
        "code": "package PrivateImportTest {\n\tpackage P1 {\n\t\tpart def A;\n\t}\n\tpackage P2 {\n\t\tprivate import P1::*;\n\t}\n\n\tpart x: P1::A;\n\t\n\timport P2::*;\n\t// This should fail.\n\t// A is not visible, because the import in P2 is private.\n\t// part y: A;\n\t// part y1: P2::A;\n\t\n\tpackage P3 {\n\t\tpart def B;\n\t}\n\t\n\tprivate import P3::*;\n\t\n\t// This should not fail.\n\t// Private import only restricts visibility outside the package.\n\tpart z: B;\n\t\n\tpackage P4 {\n\t\timport all P2::*;\n\t\t\n\t\t// This should not fail because \"import all\" overrides private import.\n\t\tpart z1: A;\n\t}\t\n}",
        "description": "The SysML-V2 code demonstrates package visibility and import rules, showing how private imports restrict access to parts and how \"import all\" overrides private import restrictions within nested packages."
    },
    {
        "code": "package CircularImport {\n\n\tpackage P1 {\n\t\timport P2::*;\n\t\tpart def A;\n\t}\n\tpackage P2 {\n\t\timport P1::*;\n\t\tpart def B;\n\t}\n\tpackage Test1 {\n\t\timport P1::*;\n\t\tpart x: A;\n\t\tpart y: B;\n\t}\n\tpackage Test2 {\n\t\timport P2::*;\n\t\tpart x: A;\n\t\tpart y: B;\n\t}\n\t\n\tpart x: P1::A;\n\t\n\t// The following should not fail.\n\tpart y: P1::B;\n\t\n}",
        "description": "The SysML-V2 code defines a circular import scenario between packages P1 and P2, each containing part definitions A and B, and demonstrates their usage in separate test packages and direct part references, ensuring no failure in resolving these circular dependencies."
    },
    {
        "code": "package AliasImport {\n\tpackage Definitions {\n\t    part def Vehicle;\n\t    \n\t    alias Car for Vehicle;\n\t}\n\t\n\tpackage Usages {\n\t    import Definitions::Car;\n\t\n\t    part vehicle : Car;\n\t}\n}",
        "description": "The SysML-V2 code defines a part type \"Vehicle\" and an alias \"Car\" for it, then imports and uses the alias \"Car\" in a different package to declare a part named \"vehicle.\""
    },
    {
        "code": "package QualifiedNameImportTest {\n\tpackage P1 {\n\t\tpart def A;\n\t}\n\tpackage P2 {\n\t\tpackage P2a {\n\t\t\timport P1::*;\n\t\t}\n\t\t// The following should not fail.\n\t\t// A is a member of P2a because of the import.\n\t\tpart x: P2a::A;\n\t}\n}",
        "description": "The SysML-V2 code demonstrates the use of qualified name imports to access and reference part definitions across nested packages, ensuring that imported elements are correctly recognized and utilized within the scope of the importing package."
    }
]